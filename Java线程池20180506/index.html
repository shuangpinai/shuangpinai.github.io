<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><header id="header" class="header" itemscope itemtype="//schema.org/WPHeader"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="Java多线程,"><meta name="description" content="本文主要介绍java线程池相关的内容，包括线程池的几种常用方式"><meta name="keywords" content="Java多线程"><meta property="og:type" content="article"><meta property="og:title" content="Java线程池"><meta property="og:url" content="http://lebens.top/Java线程池20180506/index.html"><meta property="og:site_name" content="Lebens"><meta property="og:description" content="本文主要介绍java线程池相关的内容，包括线程池的几种常用方式"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://lebens.top/images/java多线程/线程池继承结构图.jpeg"><meta property="og:image" content="http://lebens.top/images/java多线程/线程池任务分配.png"><meta property="og:updated_time" content="2018-05-09T07:26:41.013Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java线程池"><meta name="twitter:description" content="本文主要介绍java线程池相关的内容，包括线程池的几种常用方式"><meta name="twitter:image" content="http://lebens.top/images/java多线程/线程池继承结构图.jpeg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://lebens.top/Java线程池20180506/"><title>Java线程池 | Lebens</title><style>.forkme{display:none}@media (min-width:768px){.forkme{display:inline}}</style></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><div class="forkme"><a target="_blank" href="https://github.com/shuangpinai"><img style="position:absolute;top:0;left:0;border:0" src="https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png"></a></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Lebens</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>主页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>日志</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#00d9cf;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://lebens.top/Java线程池20180506/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Lebens"><meta itemprop="description" content=""><meta itemprop="image" content="https://avatars1.githubusercontent.com/u/10048597?v=4"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Lebens"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java线程池</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:44:21+08:00">2018-05-06 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>本文主要介绍java线程池相关的内容，包括线程池的几种常用方式</p><a id="more"></a><h3 id="线程池存在的意义"><a href="#线程池存在的意义" class="headerlink" title="线程池存在的意义"></a>线程池存在的意义</h3><p><strong>先抛一个问题，Thread能直接新建并使用，为什么还要使用线程池?</strong></p><p>如果看过我之前写的博客的话可以知道，一个线程从新建到死亡，总共有5个状态。创建、运行包括死亡都会消耗cpu等系统资源。如果子线程每次执行的任务量很小，但是数量很大时，你会发现，基本上所有的系统资源都消耗在线程管理上。同时线程之间的执行权竞争也会消耗一定的系统资源，这就导致了程序的执行效率降低。另外还有一点就是，随意新建的线程无法做到统一管理。线程池的存在就是为了解决上面提到的问题，以提高程序的执行效率。</p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor其实更准确的解释是执行器，定义了一个线程执行的规范，跟我们常说的线程池相差有点远。</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p><p>这段话的意思是，Executor是用来执行被提交的Runnable任务的。这个接口提供了一种将任务提交与每个任务如何运行的机制解耦的方式，包括线程使用，调度等细节。通常Executor用来代替显示的创建线程。</p></blockquote><p>上面是官方给的注释，那Executor这跟我们今天要说的线程有什么关系呢。</p><p>其实Executor是线程池的父类，最终的实现类有两个ThreadPoolExecutor以及ScheduledThreadPoolExecutor，其中ThreadPoolExecutor就是我们常说的线程池。</p><p>在ThreadPoolExecutor之上还有一个接口ExecutorService，定义了任务提交、执行等一些相关接口，继承结构图如下所示：</p><p><img src="../../images/java多线程/线程池继承结构图.jpeg" alt="线程池继承结构图"></p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>相对于Executor，ExecutorService更多是功能的定义，提供了诸如</p><ol><li><t>Future<t>submit(Callable<t>task);</t></t></t></li><li>Future&lt;?&gt; submit(Runnable task);</li></ol><p>的方法，可以让线程执行返回结果。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>这个才是我们常用的“线程池”，主要来看一下构造函数。</p><p>ThreadPoolExecutor有4个构造函数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,                             </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,                          </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,                           </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,                                </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;          </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,                             </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,                          </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,                           </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,                                </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,            </span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </span><br><span class="line">         threadFactory, defaultHandler);                                </span><br><span class="line">&#125;                                                                       </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,                             </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,                          </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,                           </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,                                </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,            </span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;           </span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </span><br><span class="line">         Executors.defaultThreadFactory(), handler);                    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,                            </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,                         </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,                          </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,                               </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,           </span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,                 </span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;          </span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||                                            </span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||                                        </span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||                              </span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)                                             </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();                          </span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                              </span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?                   </span><br><span class="line">            <span class="keyword">null</span> :                                                     </span><br><span class="line">            AccessController.getContext();                             </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;                                  </span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;                            </span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;                                        </span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);                  </span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;                                </span><br><span class="line">    <span class="keyword">this</span>.handler = handler;                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后都是调用到了参数最长的那个，我们来看一下里面个各个参数的意思：</p>
<ul>
<li>corePoolSize ： 核心线程的数量</li>
<li>maximumPoolSize ： 最大线程数量，包括核心线程和非核心线程</li>
<li>keepAliveTime ： 非核心线程空闲时存活的时间</li>
<li>unit ： 存活时间的时间单位</li>
<li>workQueue ： 任务队列</li>
<li>threadFactory ： 创建线程的工厂类</li>
<li>handler ： 当任务无法被处理的对象</li>
</ul>
<h4 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h4><p>关于corePoolSize、maximumPoolSize和workQueue这里要单独拿出来讲一下。</p>
<p>首先要明确两个概念：<strong>核心线程</strong>和<strong>非核心线程</strong>。</p>
<p><strong>核心线程</strong>是指线程空闲时也保存的线程池中的线程，最大数量就是corePoolSize个，当然如果设置了allowCoreThreadTimeOut，那么核心线程也会被回收。</p>
<p><strong>非核心线程</strong>是指核心线程不够处理任务，同时线程池稍微到达maximumPoolSize时添加的线程，这些线程会在空闲keepAliveTime后被回收。</p>
<p>但是保存在线程池中的线程并没有真正的核心线程和非核心线程的区别，只是开始回收线程时，线程数量达到核心线程的数量便不再回收。</p>
<p>知道上面这个两个我们就可以接着往下讲了。</p>
<p><strong><em>什么时候新建核心线程</em></strong></p>
<p>当线程池的线程数量少于corePoolSize时，不管是否有核心线程空闲，只要来新任务，都是直接新建核心线程用来出来任务。</p>
<p><strong><em>什么时候新建非核心线程</em></strong></p>
<p>这个问题比较复杂一点，因为涉及到workQueue的类型以及容量问题，直接一点的的回答就是：</p>
<ul>
<li><p>当workQueue被塞满时，这时来新的任务才会新建非核心线程进行处理，如果线程池中的线程数量达到了maximumPoolSize，这时再来新任务将被拒绝，同时抛出一个RejectedExecutionException。</p>
</li>
<li><p>但是存在一个特殊的情况，那就是设置的<strong>核心线程数量为0，这个时候会新建一个非核心线程</strong>用于处理任务</p>
</li>
</ul>
<p><strong><em>什么时候将任务放入workQueue</em></strong></p>
<p>当线程池中的核心线程达到了corePoolSize，同时没有核心线程空闲，这时来新的任务都会被放入workQueue，当workQueue被塞满时就会尝试新建非核心线程。</p>
<p>所以我们可以看到，一个线程池中线程池中能存在的<strong>最大线程个数</strong>就是maximumPoolSize，但是能保存的<strong>最大任务数</strong>就会比这个大一点，是maximumPoolSize + workQueue.size() 之和。</p>
<p>大致的流程下图所示：</p>
<p><img src="../../images/java多线程/线程池任务分配.png" alt="线程池任务分配图"></p>
<p>下面是demo验证一下正常情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, Integer.MAX_VALUE, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        System.out.println(<span class="string">"runnable index is "</span> + index</span><br><span class="line">                                + <span class="string">" and time is "</span> + System.currentTimeMillis());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//workers 在线程池中用保存有新建完的线程，由于不存在直接获取的方法，这里用反射获取</span></span><br><span class="line">            Class clazz = executor.getClass();</span><br><span class="line">            Field workers = clazz.getDeclaredField(<span class="string">"workers"</span>);</span><br><span class="line">            workers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                HashSet hashSet = (HashSet) workers.get(executor);</span><br><span class="line">                System.out.println(<span class="string">"Queue size is "</span> + executor.getQueue().size()</span><br><span class="line">                        + <span class="string">" and thread count is "</span> + hashSet.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">time is <span class="number">1525846211057</span> and thread count is <span class="number">1</span></span><br><span class="line">runnable index is <span class="number">0</span> and time is <span class="number">1525846211260</span></span><br><span class="line">runnable index is <span class="number">1</span> and time is <span class="number">1525846211464</span></span><br><span class="line">runnable index is <span class="number">2</span> and time is <span class="number">1525846211665</span></span><br><span class="line">runnable index is <span class="number">3</span> and time is <span class="number">1525846211870</span></span><br><span class="line">time is <span class="number">1525846212062</span> and thread count is <span class="number">1</span></span><br><span class="line">runnable index is <span class="number">4</span> and time is <span class="number">1525846212074</span></span><br><span class="line">time is <span class="number">1525846213064</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846214069</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846215070</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846216074</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846217076</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846218079</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846219084</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846220089</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846221092</span> and thread count is <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>由于没有提供直接获取线程池中当前线程数量方法，用反射的方法来获取。</p>
<p>可以看到，就算非核心线程数量设置到了Integer.MAX_VALUE，但是任务队列并没有满，还是只有1个核心线程在执行任务。并且过了超时时间，线程并没有被销毁。</p>
<p>再来一个demo验证一下核心线程设置为0的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        System.out.println(<span class="string">"runnable index is "</span> + index</span><br><span class="line">                                + <span class="string">" and time is "</span> + System.currentTimeMillis());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//workers 在线程池中用保存有新建完的线程，由于不存在直接获取的方法，这里用反射获取</span></span><br><span class="line">            Class clazz = executor.getClass();</span><br><span class="line">            Field workers = clazz.getDeclaredField(<span class="string">"workers"</span>);</span><br><span class="line">            workers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                HashSet hashSet = (HashSet) workers.get(executor);</span><br><span class="line">                System.out.println(<span class="string">"Queue size is "</span> + executor.getQueue().size()</span><br><span class="line">                        + <span class="string">" and thread count is "</span> + hashSet.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">time is <span class="number">1525846316180</span> and thread count is <span class="number">1</span></span><br><span class="line">runnable index is <span class="number">0</span> and time is <span class="number">1525846316383</span></span><br><span class="line">runnable index is <span class="number">1</span> and time is <span class="number">1525846316589</span></span><br><span class="line">runnable index is <span class="number">2</span> and time is <span class="number">1525846316793</span></span><br><span class="line">runnable index is <span class="number">3</span> and time is <span class="number">1525846316999</span></span><br><span class="line">time is <span class="number">1525846317184</span> and thread count is <span class="number">1</span></span><br><span class="line">runnable index is <span class="number">4</span> and time is <span class="number">1525846317201</span></span><br><span class="line">time is <span class="number">1525846318188</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846319193</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846320197</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846321198</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846322202</span> and thread count is <span class="number">1</span></span><br><span class="line">time is <span class="number">1525846323206</span> and thread count is <span class="number">0</span></span><br><span class="line">time is <span class="number">1525846324206</span> and thread count is <span class="number">0</span></span><br><span class="line">time is <span class="number">1525846325211</span> and thread count is <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当核心线程设置为0时，提交任务给线程池，会新建一个非核心线程用于处理任务，过了超时时间后线程就被回收了。</p>
<h3 id="Executors提供的4种默认线程池"><a href="#Executors提供的4种默认线程池" class="headerlink" title="Executors提供的4种默认线程池"></a>Executors提供的4种默认线程池</h3><p>Executors是一个线程池的工具类，最主要的用处就是给我们提供了4种常用的线程池的创建方式。</p>
<h4 id="newFixedThreadPool-int-nThreads"><a href="#newFixedThreadPool-int-nThreads" class="headerlink" title="newFixedThreadPool(int nThreads)"></a>newFixedThreadPool(int nThreads)</h4><p>这个静态返回一个固定线程数量的线程池，来看一下里面的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;          </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                     </span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,              </span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就开始用到文章上面所解释的参数的意义，这里可以看到，核心线程和最大线程数量都为指定的nThreads，非核心线程超市时间为0，也就是默认值，任务队列为一个LinkedBlockingQueue。</p>
<p>解释一下为什么这是一个固定线程的线程池，结合上面的任务分配图可以很清楚的知道，</p>
<ol>
<li>当新任务来时，最开始肯定是新建核心线程进行任务直接处理</li>
<li>当核心线程满了之后就是任务入队了，但是LinkedBlockingQueue理论上是一个无限大的队列，可以一直存放任务，这个线程池中不会存在非核心线程，线程的数量也就固定了。</li>
</ol>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h4><p>这个就是新建一个只有一个核心线程的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;              </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService                     </span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,                                  </span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,             </span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就不多解释了，看上面就知道了，只是把核心线程数指定为了1。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h4><p>这就是不限制线程的数量，但是线程会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,              </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,             </span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是套用上面的任务分配图：</p>
<ol>
<li>核心线程数量为0，以为这所有的任务都先进任务队列</li>
<li>但是SynchronousQueue是一个同步的队列，也就是SynchronousQueue中不会存在任务，只要有新任务都是直接分配出去处理。</li>
<li>最大线程数量为Integer.MAX_VALUE，意味着可以处理的任务是无限量的。</li>
<li>看完上面几点可以知道，当有任务来时都是交给非核心线程处理的，线程数量不够时直接新建非核心线程。所有线程空闲超过60秒将会被回收，这也是Cached的含义。</li>
</ol>
<h4 id="newScheduledThreadPool-int-corePoolSize"><a href="#newScheduledThreadPool-int-corePoolSize" class="headerlink" title="newScheduledThreadPool(int corePoolSize)"></a>newScheduledThreadPool(int corePoolSize)</h4><p>这个线程池主要用于执行需要重复执行的任务上，可以指定任务循环执行的模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(          </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;                  </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,              </span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后其实是新建了一个ThreadPoolExecutor，设置的核心线程数为corePoolSize，队列为一个无限大小的延时队列。</p>
<p>三个方法说明一下：</p>
<ol>
<li><p>schedule(Runnable command,long delay,TimeUnit unit)：就是一个只执行一次的延时任务，这个方法接受3个参数</p>
<ul>
<li>执行的任务</li>
<li>延时的时间</li>
<li>时间单位</li>
</ul>
</li>
<li><p>scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)： 这是一个无限次执行的延时任务，这个方法接受4个参数</p>
<ul>
<li>执行的任务</li>
<li>第一次开始执行的延时</li>
<li>以后每次开始的延时</li>
<li>时间单位</li>
</ul>
</li>
<li><p>scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)：这是一个无限次执行的延时任务，只不过每次新任务总在上一个任务执行完毕开始，这方法接受4个参数</p>
<ul>
<li>执行的任务</li>
<li>第一次开始执行的延时</li>
<li>上个任务结束后，开始下个任务的延时</li>
<li>时间单位 </li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇基本上算都是干货了，总结没啥好写的，再看一遍文章，能记住的都记住吧，特别是文中提到的几个问题。</p>
      
    </div>
    
    
    

    
      <div>
        <br>
        <div>
    
        <div style="text-align:center;color:#ccc;font-size:14px">-------------THE END-------------</div>
    
</div>
      </div>
    

    <div>
      
        <br>
        
<style>.my_post_copyright{padding:1px 0 1px 20px!important;margin-left:5px;border-left:3px solid #ed3726}.my_post_copyright p{line-height:1.5;margin:10px 0}.my_post_copyright p span{font-weight:700;padding-right:15px}</style>
<div class="my_post_copyright">
  <p><span>本文标题:</span><a href="/Java线程池20180506/">Java线程池</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Lebens 的个人博客">Lebens</a></p>
  <p><span>发布时间:</span>2018年05月06日 - 12:05</p>
  <p><span>最后更新:</span>2018年05月09日 - 15:05</p>
  <p><span>原始链接:</span><a href="/Java线程池20180506/" title="Java线程池">http://lebens.top/Java线程池20180506/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://lebens.top/Java线程池20180506/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script>var clipboard=new Clipboard(".fa-clipboard");clipboard.on("success",$(function(){$(".fa-clipboard").click(function(){swal({title:"",text:"复制成功",html:!1,timer:500,showConfirmButton:!1})})}))</script>

      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java多线程/" rel="tag"># Java多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Java同步实现方式20180504/" rel="next" title="Java同步实现方式">
                <i class="fa fa-chevron-left"></i> Java同步实现方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Java线程简介20180507/" rel="prev" title="Java线程简介">
                Java线程简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/10048597?v=4" alt="Lebens">
            
              <p class="site-author-name" itemprop="name">Lebens</p>
              <p class="site-description motion-element" itemprop="description">我相信，梦里能到达的地方，总有一天，脚步也能到达</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/shuangpinai" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/44348e1d53c4" target="_blank" title="简书">
                    
                      <i class="fa fa-fw fa-globe"></i>简书</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.csdn.net/zzhouqianq" title="易凌风" target="_blank">易凌风</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://cdevlab.top/" title="chendong" target="_blank">chendong</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池存在的意义"><span class="nav-number">1.</span> <span class="nav-text">线程池存在的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">2.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">3.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">4.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程数量"><span class="nav-number">4.1.</span> <span class="nav-text">线程数量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors提供的4种默认线程池"><span class="nav-number">5.</span> <span class="nav-text">Executors提供的4种默认线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool-int-nThreads"><span class="nav-number">5.1.</span> <span class="nav-text">newFixedThreadPool(int nThreads)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">5.2.</span> <span class="nav-text">newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">5.3.</span> <span class="nav-text">newCachedThreadPool()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool-int-corePoolSize"><span class="nav-number">5.4.</span> <span class="nav-text">newScheduledThreadPool(int corePoolSize)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
  <i class="fa fa-star"></i>
</span>
  <span class="author" itemprop="copyrightHolder">Lebens</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){var r=!1,s=0,a=0,i=n.title.trim(),c=i.toLowerCase(),l=n.content.trim().replace(/<[^>]+>/g,""),h=l.toLowerCase(),p=decodeURIComponent(n.url),u=[],f=[];if(""!=i&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}u=u.concat(e(t,c,!1)),f=f.concat(e(t,h,!1))}),(u.length>0||f.length>0)&&(r=!0,s=u.length+f.length)),r){[u,f].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});function d(e,o,n,r){for(var s=r[r.length-1],i=s.position,c=s.word,l=[],h=0;i+c.length<=n&&0!=r.length;){c===t&&h++,l.push({position:i,length:c.length});var p=i+c.length;for(r.pop();0!=r.length&&(s=r[r.length-1],i=s.position,c=s.word,p>i);)r.pop()}return a+=h,{hits:l,start:o,end:n,searchTextCount:h}}var g=[];0!=u.length&&g.push(d(0,0,i.length,u));for(var v=[];0!=f.length;){var $=f[f.length-1],C=$.position,m=$.word,x=C-20,w=C+80;x<0&&(x=0),w<C+m.length&&(w=C+m.length),w>l.length&&(w=l.length),v.push(d(0,x,w,f))}v.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var y=parseInt("1");y>=0&&(v=v.slice(0,y));function T(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var b="";0!=g.length?b+="<li><a href='"+p+"' class='search-result-title'>"+T(i,g[0])+"</a>":b+="<li><a href='"+p+"' class='search-result-title'>"+i+"</a>",v.forEach(function(t){b+="<a href='"+p+'\'><p class="search-result">'+T(l,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:a,hitCount:s,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script></div></body></header></html>
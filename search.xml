<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac优化之自定义全局快捷键]]></title>
    <url>%2FMac%E4%BC%98%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%BF%AB%E6%8D%B7%E9%94%AE20180426%2F</url>
    <content type="text"><![CDATA[相信很多从Win转Mac OS的同学都曾想过如果mac打开文件能像win下方便就好了，下面我们来看打开finder的2种快捷方式。系统自带的快捷键进入系统设置(System Preferences)选择键盘(Keyboard)选择快捷键(Shotcuts)选择焦点（Spotlight）勾选右侧的现实访达焦点窗口(Show Finder search window)如上可以打开自动自带的打开finder的快捷方式，试一下效果自定义全局快捷键接下来一下通过新建Service的方式自定义全局快捷键，这里并不局限于打开finder进入二级菜单页面打开其他选择Automator新建Service左侧菜单栏选择Utilities,同时选中Launch Application上方”Service Receives Selected”（服务接收选择），选择“no input”(任何应用程序)下方app选择，点击后拉到最下方，选择New Variable(新建)Path(路径)选择Other(其他)搜索Finder，并选中Finder.appcommand+s保存，保存自己的Service名(下一步有用)打开键盘的快捷键找到Services(服务)，选择刚刚新建的Service，并添加快捷键，完工！试一下效果：]]></content>
      <categories>
        <category>Mac OS X</category>
      </categories>
      <tags>
        <tag>Mac优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Looper、Handler、Message以及MessageQueue之间的关系]]></title>
    <url>%2FLooper%E3%80%81Handler%E3%80%81Message%E4%BB%A5%E5%8F%8AMessageQueue%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB20180424%2F</url>
    <content type="text"><![CDATA[本文主要讲解Android线程间通信的一种方式，即Handler机制。子线程使用Handler相信很多童鞋有过子线程中new Handler时系统报错的经历123java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()at android.os.Handler.&lt;init&gt;(Handler.java:203)at android.os.Handler.&lt;init&gt;(Handler.java:117) 报错的原因是，在没有调用过Looper.prepare()的子线程中不能new Handler。 正确的使用方式是 123456789new Thread() &#123; @Override public void run() &#123; Looper.prepare(); Looper looper = Looper.myLooper(); Looper.loop(); Handler handler = new Hander(); &#125; &#125;.start(); 这到底是什么原因，Handler的构造函数做了什么操作，Looper.prepare()做了什么处理，我们接着往下看。 Handler12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 这里可以很清晰的看到抛出的异常 12345mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; 接着看Looper中的实现。 Looper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final class Looper &#123; ... // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; ... /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; ... /** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked(); &#125; &#125;&#125; 上面贴了Looper的一些主要代码，主要工作流程如下： prepare() 中就做了一件事，用ThreadLoacl在当前Thread中保存了一份Looper实例对象，并保证了每个线程只拥有一个Looper实例对象，保证循环中的消息队列的唯一性。有兴趣的童鞋可以看看这个ThreadLocal类详解。 myLooper() 就是将当前线程中保存的Looper对象返回。 loop() 开启MessageQueue中消息列表的循环处理，若当前无消息则阻塞，有消息则发送。 Looper和Handler的联系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class Handler &#123; ... public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis); &#125; public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis); &#125; public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis); &#125; public final boolean postAtFrontOfQueue(Runnable r)&#123; return sendMessageAtFrontOfQueue(getPostMessage(r)); &#125; public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis)&#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; //消息入队 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; ...&#125; 上面这些方法，到最后调用就是个方法 12345678//消息入队 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 在开头的Hanlder构造函数里我们可以知道，这里所用的queue就是Looper中的queue，也就是Handler中发送的消息其实入到了Looper中，两者在这里关联起来。 这也就解释了为什么Handler实例化之前需要Looper先行prepare。 这里先说明一点，post(Runnable r)等一系列方法中，最后Runnable回调都会被设置到msg中的callback中，看下面这个2方法 123456789101112private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m; &#125; 这里特做说明，下文会用到这点。 Hanlder和Message的联系上面看到handler消息入队列的时候会给msg.target赋值为this，也就是当前handler实例对象。 在Looper的loop()中message从MessageQueue取出，并调用 msg.target.dispatchMessage(msg)，并传递给他的target进行处理，也就是哪个handler发送的消息，最后又经由谁来处理。 来看一下Handler的dispatchMessage() 1234567891011121314151617181920212223242526/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; /** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; //用户自行实现的消息处理 &#125; 上面可以清晰的看到 如果msg有回调，则msg的回掉先行处理msg； 如果Handler实例化时有传入Callback，则这个Callback处理msg； 最后由用户自行实现的消息处理方式处理msg。 从上面可以看出，如果msg没有回调，则都会回到Handler所在线程进行处理。这也就是可以利用Handler更新UI的原理。 好了，Hanlder机制的整体流程如下图所示(图片来源网络，侵删)： 文章看完了，肯定有童鞋有疑问，为什么在UI线程new Handler时不需要先进行Looper.perpare()，原因是系统自动帮你完成了UI线程Looper.perpare()操作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal类详解]]></title>
    <url>%2FThreadLocal%E7%B1%BB%E8%AF%A6%E8%A7%A320180423%2F</url>
    <content type="text"><![CDATA[Android中Handler中有使用到ThreadLocal相关的知识，本文对ThreadLocal源码做一次解读ThreadLocal的特性ThreadLocal是线程本地保存数据的变量，这也是“ThreadLocal”的字面意思。同一个ThreadLocal对象，在不同线程中可以保存不同的数据，每个线程都有自己独一份的ThreadLocalMap来保存数据，ThreadLocal对象只不过起到key的作用一个线程中可以有多个ThreadLocal对象，但是同一个ThreadLocal只能保存一份值，多次保存会替换之前保存的值理论上数据有所在线程独享，但是如果存入的数据被多线程访问，那还是会有并发访问的问题。所以ThreadLocalMap保存的数据并不建议保存共享数据。线程销毁后自动释放线程保存的数据。线程本地保存数据，提高数据访问的速度。ThreadLocal内部实现变量12//相当于ThreadLocal的hash，保存数据到ThreadLocalMap时用于确定存储的位置private final int threadLocalHashCode = nextHashCode(); 12//自增长的int值，静态变量，保证不重复private static AtomicInteger nextHashCode = new AtomicInteger(); 1234567//每次threadLocalHashCode增长都要加上这个值，注释写的，为了让哈希码能均匀的分布在2的N次方的数组里/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647; 123456/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 方法 1234//提供默认值，子类继承时可以复写protected T initialValue() &#123; return null;&#125; 1234567891011//返回保存在当前线程ThreadLocalMap中的T值，若map为null则返回默认值public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 123456789//保存T到当前线程的ThreadLocalMap中public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 1234567//清除保存的数据//因为数据本来就是保存在线程中，清除数据也不是必须操作， 但可以加快内存回收public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 上面是ThreadLocal内部基本的几个方法，我们接着来看ThreadLocal怎么好Thread联系起来。 set()方法会调用到createMap(),看一下源码 12345678910111213/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map * @param map the map to store. */ //这里可以很清除的看到，其实是new了ThreadLocalMap，并保存到了Thread中 //查看Thread的源码也可以看到，内部保存了一个ThreadLocalMap变量 void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 内部类 ThreadLocal内部定义了ThreadLocalMap类，并不是一个map类，内部使用WeakReference来操作数据，保存、获取等数据操作的实现都在这里。 123456789101112131415161718192021222324252627282930313233static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125; &#125; ... /** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */ private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; &#125; 看过HashMap源码实现的同学看到这里肯定不会陌生，这就相当于是HashMap的实现，只不过这里取出来的数据不是链接，是Entry对象。 其他方法不再赘述，有兴趣的同学可以自行查看HashMap与ThreadLocalMap源码做比较。 没有看过HashMap源码的同学也可以看这篇HashMap源码解析 代码分析 通过上面的代码可以看到，每次set(）以及get()都会获取到当前线程再做后续的操作，保证所有的数据跟当前的线程相关联，不干扰其他线程。 在 set()和 get() 我们可以看到，保存数据的ThreadLocalMap对象，其实是保存在当前线程中，并不是保存在ThreadLocal中，也就解释了，为什么不同的线程可以取到自己线程中保存的值，ThreadLocal只是起到了key的左右。 数据真正保存在ThreadLocalMap中，再看一下getEntry()，通过threadLocal的threadLocalHashCode来确定返回值，这个就相当于threadLocal为key获取到之前保存的数据。同时每次new ThreadLocal对象时，threadLocalHashCode做了相对性的自增，这样可以保证多个threadLocal对象能被正确区分。 ThreadLocal保存的数据对象是T类型，意味着我们要存多个数据时可以保存Map或者List等类型，不用没保存一个数据就new一个对象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2FHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020180417%2F</url>
    <content type="text"><![CDATA[本文针对HashMap源码中的一些重要方法做讲解。Android中的HashMap与java中HashMap实现有差异，这里以Android的源码为例进行讲解。成员变量说明1234561. int DEFAULT_INITIAL_CAPACITY = 4；//默认初始化的容量2. int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //HashMap最大的容量3. float DEFAULT_LOAD_FACTOR = 0.75f; //判断是否扩容时用的计算因子4. int threshold ; //用于比较是否该扩容，其值为 capacity * load factor5. int size; //当前存储的数据容量6. HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE;//数据存储在这 成员变量tableHashMap内部实现的是Map.Entry 的，数据以数组形式保存的链表。 1transient HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE; 看一下HashMapEntry里面的代码，很简单： 123456789 /** @hide */ // Android added. static class HashMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; HashMapEntry&lt;K,V&gt; next; int hash; ...&#125; 保存了数据的key、value、hash以及以及下一个数据，就是典型的链表储存形式。至于put进来的数据，如何确定保存在table中的位置，请看下文。 构造函数构造函数主要对初始化容量以及加载因子做了参数校验，以符合后续的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); //初始化容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; initialCapacity = MAXIMUM_CAPACITY; &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123; initialCapacity = DEFAULT_INITIAL_CAPACITY; &#125; //校验加载因子的准确性 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Android-Note: We always use the default load factor of 0.75f. // This might appear wrong but it's just awkward design. We always call // inflateTable() when table == EMPTY_TABLE. That method will take "threshold" // to mean "capacity" and then replace it with the real threshold (i.e, multiplied with // the load factor). //默认扩容的阀值就是初始的容量 threshold = initialCapacity; init(); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#125; 数据put操作最基本的数据保存的方法，下面细分讲解: 12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 操作流程如下： 内部回判断当前table是否为空，为空则初始化table， table不为空，则查询当前的key是否在table中有保存，有则用新value替换旧value，并返回旧value 若当前key未保存数据，则创建新的entry进行保存（中间有一步扩容的操作） table初始化123456789101112131415161718192021 /** * Inflates the table. */ private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize //取最靠近（大于等于）toSize的2的整数倍值 int capacity = roundUpToPowerOf2(toSize); // Android-changed: Replace usage of Math.min() here because this method is // called from the &lt;clinit&gt; of runtime, at which point the native libraries // needed by Float.* might not be loaded. float thresholdFloat = capacity * loadFactor; if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123; thresholdFloat = MAXIMUM_CAPACITY + 1; &#125;//真正初始化临界值 threshold = (int) thresholdFloat; table = new HashMapEntry[capacity]; &#125; 看一下里面取2整数倍的方法 12345678910 private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : "number must be non-negative"; int rounded = number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (rounded = Integer.highestOneBit(number)) != 0//最高位为0，直接返回1 ? (Integer.bitCount(number) &gt; 1) ? rounded &lt;&lt; 1 : rounded//如果高位1的个数大于1，肯定不是2的整数倍，rounded扩大一倍，保证比number大 : 1; return rounded;&#125; 对于里面Integer.bitCount()不理解的同学可以参考这篇文章 Integer.bitCount实现过程 value存储对key进行判断，若key为null则存储到table的第一位，否则查找应该存储的位置 12int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);int i = indexFor(hash, table.length); 每次put以及get都会用到上面2个方法，hash值用于确定entry在table中的位置 看一下indexFor() 123456789101112131415161718192021222324 /** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; //上文可以知道table的length一定为2的倍数，这里length-1转换成二进制的时候可以肯定所有的位数都为1， //h &amp; (length-1)可以保证不同的hash值在table里分布 return h &amp; (length-1); &#125;``` 获取到index之后，去查找对应的链表，并循环遍历是否有保存的value，有则替换，否则插入新数据```java for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 来看一下插入数据的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; //这里用到了上面提到的threshold，到达临界值，同时当前插入的位置上有链表后，进行扩容，并将数据重新存入（length改变后，同一个hash值通过indexFor()计算得到的位置可能会变） if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125;``` ### 数据get操作相对put操作，get就比较简单了```java /** * Returns the entry associated with the specified key in the * HashMap. Returns null if the HashMap contains no mapping * for the key. */ final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; // 找到table中的链表位置后遍历循环比较取出数据即可 int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 遍历遍历的方法主要有3个 keySet(); values(); entrySet(); 这三个方法内部都是用的各自实现的HashIterator来进行遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; HashMapEntry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot HashMapEntry&lt;K,V&gt; current; // current entry HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry HashMapEntry[] t = table; //找到第一个不为null的HashMapEntry while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); HashMapEntry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; //如果当前链表遍历完了，则查找下一个不为null的链表的位置 HashMapEntry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125;&#125; 总结 HashMap插入数据不同步，所以是线程不安全的 内部使用链表 + 数组的形式保存所有的数据 每次扩容都是当前容量的2倍]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码分析]]></title>
    <url>%2FLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020180410%2F</url>
    <content type="text"><![CDATA[集合系列中的LinkedList的源码解析LinkedList内部实现LinkedList内部定义的Node静态类1234567891011private static class Node&lt;E&gt; &#123; E item;//数据 Node&lt;E&gt; next;//下一个Node节点，当前为链表尾时为null Node&lt;E&gt; prev;//上一个Node节点，当前为链表头时为null Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 通过Node的定义可以知道，内部其实是一个双向链表，分别保存了前后两个节点的指向。 内部定义了两个成员变量first以及last，用于快速的获取当前数据的第一个和最后一个数据。不管是实现list还是queue，直接操作first和last方法只有如下4个： 123456789101112131415/** * Links e as first element. * 将元素添加到首位 */ private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode;//链表如果为空，则第一个元素也是最后一个元素 else f.prev = newNode;//修改之前元素的指向 size++; modCount++; &#125; 123456789101112131415/** * Links e as last element. * 将元素添加到末尾 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//链表如果为空，则第一个元素也是最后一个元素 else l.next = newNode;//修改之前元素的指向 size++; modCount++; &#125; 1234567891011121314151617181920/** * Unlinks non-null first node f. * 将一个非空的节点从首位移除 */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; 12345678910111213141516171819/** * Unlinks non-null last node l. * 将一个非空的节点从末尾移除 */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; 从上面的方法可以看到，操作first和last顶多就是修改一下指针的指向，效率很高。 关于位置的查找，最终调用的如下2个方法：12345678910111213141516171819 public int indexOf(Object o) &#123; int index = 0; //元素分为null以及非null两种情况，提交一点比较时的效率 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 12345678910111213141516 Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index);//index在前一半则从前往后遍历，否则从后往前，减少几次遍历，提高一点效率 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; List以及Dequeue的实现list以及Deque的抽象实现，内部其实都是调用到linkFirst()、linkLast()、unLinkFirst()、unLinkLast()不再赘述。 LinkedList特性 内部使用链表结构实现，特点是增、删快，查询慢（需要从头遍历） 实现了Deque接口，也可以当作Queue来使用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码解析]]></title>
    <url>%2FArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9020180409%2F</url>
    <content type="text"><![CDATA[本文主要对ArrayList源码做一次解析，以及个人的理解做一次记录ArrayList的实现通过对源码的阅读可以发现，ArrayList内部的所有操作，都是对内部初始化的 Object [] 的操作。这意味着对内部数据的查询相对较快速，因为数组有角标可以快速访问，相对的对数据进行增、删效率就没那么高了（数组定长，对数据的修改都是一次copy）里面的代码也相对比较简单，挑如下几个方面说一下主要的实现ArrayList数据操作主要方法get(int index);//获取指定位置的数据set(int index, E element);//将数据设置到指定位置add(E e);//将数据添加到最后add(int index, E element);//将数据添加到指定位置remove(int index);//移除指定位置的数据remove(Object o);//移除指定的数据clear();//清除所有数据addAll(Collection&lt;? extends E&gt; c);//将整个集合添加进去addAll(int index, Collection&lt;? extends E&gt; c);//从指定位置开始添加整个集合removeRange(int fromIndex, int toIndex);//删除指定范围的数据retainAll(Collection&lt;?&gt; c);//保留两个list的交集ArrayList对内部数据的操作主要有如上10个方法。在操作几个添加数据相关方法时会对当前的数组进行容量判断，如果不够则进行扩容，默认是增加当前容量的一半。对数据的增删主要通过System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);实现。System.arraycopy这个方法表示将src这个数组的数据从srcPos开始一共length长度的数据，复制到dest这个数组的destPos位之后。ArrayList的扩容先看如下这几个方法，实现的ArrayList扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 每次增删数据前都会判断当前数组的容量，判断的方法主要是ensureCapacity()和ensureCapacityInternal()，一个公开一个内部调用，调用之后如果数据容量不够都会调用grow()做扩容处理。 来看一下grow()代码实现,添加了注释。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//如果容量不够先扩容一半 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity;//还不够直接使用指定的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity);//扩容至最大容量 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//数据重新拷贝赋值&#125; 方法分析看一下如下几个主要的方法 12345678910public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index);//这里相当于将数据做了一次移动，将index之后的数据统一往后移动了1位 elementData[index] = element;//同时将index的数据进行了重新复制 size++;&#125; 123456789101112131415public E remove(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved);//同add方法，这里将index之后的数据统一往前移动了1位 elementData[--size] = null; //同时这里是通过复制实现的移动最后一位数据现在是多余的，清除 return oldValue;&#125; 12345678910111213141516171819public boolean remove(Object o) &#123;//这里对数据做了是否为null的区分，节省了equals的比较 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678910private void fastRemove(int index) &#123; modCount++; //这一步的操作是判断是否是最后一位，最后一位不需要数据拷贝移位 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //最后一位数据肯定多余&#125; 12345678910111213141516171819 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount//这里确定是否需要将原数组的数据往后移位 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved);//将新数据拷贝进对应的位置 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 12345678910111213141516171819202122protected void removeRange(int fromIndex, int toIndex) &#123; // Android-changed : Throw an IOOBE if toIndex &lt; fromIndex as documented. // All the other cases (negative indices, or indices greater than the size // will be thrown by System#arrayCopy. if (toIndex &lt; fromIndex) &#123; throw new IndexOutOfBoundsException("toIndex &lt; fromIndex"); &#125; modCount++; //确定需要移位的数据 int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125;public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) //这里通过一个boolean值来区分，保留下的数据到底是不是交集 if (c.contains(elementData[r]) == complement) //这里很巧妙了保存了需要的数据 elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. //这里的if判断是防止上面try里面报异常，将已经修改的数据继续做保存操作 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; //清除多余的数据 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 总结 初始容量为10，每次扩容为当前容量的一半 内部维护一个size字段用于表示当前数据大小 主要通过System.arrayCopy()对数据做复制、移位等处理 由于内部使用数组实现，查询时可以通过脚标查询效率高，跟新数据则效率低]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类分析]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%E5%88%86%E6%9E%9020180409%2F</url>
    <content type="text"><![CDATA[本文主要对java中集合相关的知识点做一个汇总，后续会分析相关的常用子类继承关系图java集合继承关系如下所示：123456789101112131415161718Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack│└Set ├HashSet ├TreeSet └LinkedHashSetMap├Hashtable├HashMap├TreeMap├LinkedHashMap└WeakHashMap Collection没有直接的实现类，让其被继承产生了两个接口，如上图所示，就是Set和List。 Set中不能包含重复的元素，同时数据的存储并不是有序的（存入和取出的顺序不一定相同）。 List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 集合中的另一个接口就是Map。Map包含了key-value对，Map不能包含重复的key，但是可以包含相同的value。 集合中所有的类都实现了Iterator接口，用于遍历、操作集合中的数据，主要有如下几个方法： hasNext()；是否还有下一个元素。 next()；返回下一个元素。 remove()；删除当前元素。 集合子类之间的区别 List ：list数据有序，可重复。可以通过索引进行数据的增、删、改。 Arraylist使用数组实现，相对应的查询快，修改慢。适用于经常查询的场景 LinkedList使用双向链表实现，相对应的查询慢，修改快。适用于经常修改数据的场景 Set：Set数据存放无序，不可重复。 HashSet通过hashCode()和equals()来保证数据的唯一性； TreeSet通过对元素实现Comparable接口或者TreeSet指定排序规则，让元素可排序，并通过这个比较元素是否是唯一的 Map：Map已键值对的形式存放数据，键不能重复，值可以重复。 HashMap：根据key的hashCode值来区分不同的key，同时因为这个遍历时取到的key是无序的。线程不同步，相对于HashTab效率高。能存放一个null值的key（hashcode），同时不限制null值的value数量 HashTab：相对于HashMap，线程安全，同时效率也对于HashMap。存储时键值都不能为null。 TreeMap：遍历时默认按key的升序排列，这意味着key不能为null。线程不同步。 LinkedHashMap：遍历时按key插入的顺序取出，有序，相对于HashMap效率略低。线程不同步，可存放一个key为null值，value不做限制。 总结看到Array，就要想到角标，查询快。 看到Link，就要想到first，last，有序。 看到Hash，就要想到hashCode，equals，无序。 看到Tree，就要想到两个接口。Comparable，Comparator，可排序。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9520180404%2F</url>
    <content type="text"><![CDATA[目前先更新冒泡排序以及选择排序的java实现，后序更新冒泡排序通过每次比较相邻两个数据的大小，将大的数据替换到右边，逐渐将大的数据往后排。因为每次交换完成上一次最大的数据总比这次最大的数据大，所以可以忽略与上一次之前的数据比较，减少比较的次数。代码实现很简单，两个for循环，外层for循环控制循环次数，内层for循环控制比较的数据1234567891011121314private void bubbleSort(int[] array) &#123; int length = array.length; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; 选择排序从第一个数开始，跟后面的数据做比较，如果后面的数据比前面的大，则将相互调换位置，直到数据排序完成为止。 123456789101112131415161718192021private void selectSort(int[] array) &#123; int length = array.length; for (int i = 0; i &lt; length - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; length; j++) &#123; if(array[j] &lt; array[i])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树遍历]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%8620180403%2F</url>
    <content type="text"><![CDATA[主要介绍二叉树的先、中、后序遍历，使用递归和栈两种实现方式二叉树的3中遍历方式先序遍历：先跟节点遍历，再依次遍历左子树和右子树中序遍历：先遍历左子树，再遍历跟节点，最后遍历右子树后序遍历：先依次左子树和右子树，最后遍历跟节点假设有如下图所示的二叉树定义Node节点12345678910111213141516public class Node &#123; Node parent; Node left; Node right; int index; Node(int index) &#123; this.index = index; &#125; @Override public String toString() &#123; return String.valueOf(index) + " "; &#125;&#125; 先序遍历 递归实现先序遍历 打印结果为：0 1 3 7 8 4 2 5 9 10 11 12 6 1234567891011121314/** * 先序遍历--递归 * * @param root 根节点 */private void DLR(Node root) &#123; if (null == root) &#123; return; &#125; System.out.print(root.toString()); DLR(root.left); DLR(root.right);&#125; 栈实现先序遍历 打印结果为：0 1 3 7 8 4 2 5 9 10 11 12 6 1234567891011121314151617181920212223242526/** * 先序遍历--栈 * &lt;p&gt; * 维护一个栈，将根节点入栈，然后只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。 * * @param root */ private void DLRWithStack(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node temp = stack.pop(); System.out.print(temp.toString()); if (temp.right != null) &#123; stack.push(temp.right); &#125; if (temp.left != null) &#123; stack.push(temp.left); &#125; &#125; &#125; 1234567891011121314151617181920212223/** * 先序遍历--栈 * &lt;p&gt; * 利用栈模拟递归过程实现循环先序遍历二叉树 * 这种方式具备扩展性，它模拟递归的过程，将左子树点不断的压入栈，直到null，然后处理栈顶节点的右子树 * * @param root 树的根节点 */ private void DLRWithStack_2(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; System.out.print(root.toString());//先访问再入栈 stack.push(root); root = root.left;//如果是null，出栈并处理右子树 &#125; root = stack.pop(); root = root.right; &#125; &#125; 中序遍历 递归实现中序遍历 打印结果为：7 3 8 1 4 0 9 5 11 10 12 2 6 1234567891011121314/** * 中序遍历--递归 * * @param root 根节点 */private void LDR(Node root) &#123; if (null == root) &#123; return; &#125; LDR(root.left); System.out.print(root.toString()); LDR(root.right);&#125; 栈实现中序遍历 打印结果为：7 3 8 1 4 0 9 5 11 10 12 2 6 1234567891011121314151617181920212223/** * 中序遍历--栈 * &lt;p&gt; * 利用栈模拟递归过程实现循环中序遍历二叉树 * 访问的时间是在左子树都处理完直到null的时候出栈并访问。 * * @param root 树的根节点 */private void LDRWithStack(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left;//如果是null，出栈并处理右子树 &#125; root = stack.pop(); System.out.print(root.toString()); root = root.right; &#125;&#125; 后序遍历 递归实现后序遍历 打印结果为：7 8 3 4 1 9 11 12 10 5 6 2 0 123456789101112131415/** * 后序遍历 * * @param root 根节点 */private void LRD(Node root) &#123; if (null == root) &#123; return; &#125; LRD(root.left); LRD(root.right); System.out.print(root.toString());&#125; 栈实现后序遍历 打印结果为：7 8 3 4 1 9 11 12 10 5 6 2 0 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 后序遍历--栈 * &lt;p&gt; * 后序遍历时先将左子树全入栈做遍历，取出右子树做新的遍历操作 * 由于会取出多次，添加标记来区分，防止重复遍历，这里用list做标记 * * @param root 根节点 */private void LRDWithStack(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); //标记是否被遍历过 List&lt;Node&gt; list = new ArrayList&lt;&gt;(); while (!stack.empty()) &#123; Node temp = stack.peek(); //若左子树尚未被遍历 if (temp.left != null &amp;&amp; !list.contains(temp.left)) &#123; temp = temp.left; while (temp != null) &#123; stack.push(temp); temp = temp.left; &#125; continue; &#125; //若右子树尚未被遍历 if (temp.right != null &amp;&amp; !list.contains(temp.right)) &#123; stack.push(temp.right); continue; &#125; Node node = stack.pop(); list.add(node); System.out.print(node.toString()); &#125;&#125; 层遍历二叉树 打印结果为：0 1 2 3 4 5 6 7 8 9 10 11 12 1234567891011121314151617181920212223242526/** * 层遍历 * * @param root 根节点 */private void layer(Node root) &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; Node node = queue.poll(); System.out.print(node.toString()); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125;&#125; 参考文献JAVA下实现二叉树的先序、中序、后序、层序遍历（递归和循环）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类初始化]]></title>
    <url>%2Fjava%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%9620180402%2F</url>
    <content type="text"><![CDATA[本文主要记录本人对java类初始化了解的一些知识点，内容不一定正确，希望对读者有所帮助类初始化的的基本流程虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。上面所说时显示的对象创建，还有几种隐式创建对象的方式：给String类型变量赋值时，若String对象在常量池中不存在，则创建一个新的String对象对String对象进行拼接操作，同上自动装箱机制可能会引起一个原子类型的包装类对象被创建。使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类，也即main函数。类的实例对象初始化基本如下：Static Field Initial (静态变量)Static Patch Initial （静态初始化块）Field Initial （变量）Field Patch Initial （初始化块）Structure Initial （构造器）上面第一条和第二条依据代码定义的顺序不同，执行的顺序也不同（定义在静态代码块中的变量可以被静态代码块赋值，但是不能被访问）以下几种特殊情况需要说明一下：单例模式123456789101112131415161718192021222324252627282930313233public class Test &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println(Singleton.m); &#125; static class Singleton &#123; private static Singleton sSingleton = new Singleton(); private static String sString; static &#123; if (null == sString) &#123; sString = "静态代码看初始化"; &#125; &#125; private Singleton() &#123; init(); &#125; private static void init() &#123; if (null == sString) &#123; sString = "init() 初始化"; &#125; &#125; static Singleton getInstance() &#123; return sSingleton; &#125; &#125;&#125; 打印的结果为：init() 初始化 因为在初始化Singleton时，先行初始化singleton静态变量，此时调用了构造函数，并对sString进行了赋值操作。所以这里的初始化顺序对构造器中的代码执行顺序提前到了静态代码块之前。 子类引用父类的静态变量导致的初始化123456789101112131415161718192021222324252627282930313233343536373839public class Test &#123; public static void main(String[] args) &#123; System.out.println(Child.sCount); &#125; static class Parent &#123; static int sCount = 100; static &#123; System.out.println("Parent static Patch Initial"); &#125; &#123; System.out.println("Parent Field Patch Initial"); &#125; public Parent() &#123; System.out.println("Parent Constructor Initial"); &#125; &#125; static class Child extends Parent &#123; static final Integer sCount = 100; static final String sString = "hello"; static &#123; System.out.println("Child static Patch Initial"); &#125; &#123; System.out.println("Child Field Patch Initial"); &#125; public Child() &#123; System.out.println("Child Constructor Initial"); &#125; &#125;&#125; 运行结果为： Parent static Patch Initial 100 对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只触发了父类的初始化而不会触发子类的初始化。 对类中的常量引用的初始化1234public static void main(String[] args) &#123; System.out.println(Child.sString); System.out.println(Child.sCount + "");&#125; 打印的结果分别是： hello Parent static Patch Initial — 100 String和基本的数据类型，会在编译期被放进类的常量池中，所有在调用时并没有对类进行初始化。 但是Integer类型的sCount，在编译期并不会被放入常量池，通过 ‘javap -v’对编译后的字节码文件可以知道，main函数的第18行调用到了getstatic的指令，触发了类的初始化 123456789101112131415161718192021222324252627282930313233343536&#123; public Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 7: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: new #6 // class java/lang/StringBuilder 14: dup 15: invokespecial #7 // Method java/lang/StringBuilder."&lt;init&gt;":()V 18: getstatic #8 // Field Test$Child.sCount:Ljava/lang/Integer; 21: invokevirtual #9 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder; 24: ldc #10 // String 26: invokevirtual #11 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: invokevirtual #12 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 32: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 35: return LineNumberTable: line 10: 0 line 11: 8 line 12: 35&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java解析与分派]]></title>
    <url>%2Fjava%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%86%E6%B4%BE-md20180323%2F</url>
    <content type="text"><![CDATA[本文的目的近期在看java虚拟机相关的知识点，写下此文记录近期所学知识点。什么是静态解析静态解析指的是方法在程序真正执行前就有一个可确定的版本，并且这个方法的调用版本在运行期是不可变的，也就是调用目标在编译器进行编译时就必须确定下来，也即要求一个方法“编译器可知，运行期不可变”。在java中符合静态解析要求的方法主要有两大类，分别是静态方法和私有方法。私有方法不能被继承，静态方法不能被重写，这两个限制可以确定这些方法都只有唯一的版本，不存在方法的重写，这使得他们能被静态解析。Java虚拟机里共提供了四条方法调用字节指令，分别是invokestatic：调用静态方法。invokespecial：调用实例构造器方法、私有方法和父类方法。invokevirtual：调用所有的虚方法。invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用方法，符合这一条件的有静态方法、私有方法、实例构造器方法以及父类方法。这些方法包括final方法在内统称为非虚方法，与之相反的其他方法称之为虚方法final方法，虽然是被invokevirtual调用，但是由于其无法被覆写，可以在编译时期被编译器完全确定，所以也被当作非虚方法，Java语言规范中也明确说明了final方法是一种非虚方法。什么是分派相对于非虚方法，虚方法由于存在重载和覆写，方法的引用可能无法在编译器直接确定。分派根据调用时期，可以分为静态分派和动态分派，同时根据宗量数（方法的调用者和方法的型参统称为方法的宗量数）区分又可以分为单分派和多分派，组合可以分为静态单分派、静态多分派、动态单分派、动态多分派四种情况。静态分派先说结论：对于重载的方法，javac是通过形参的静态类型（静态类型编译期可知）来区分使用哪个重载版本，这就是静态分派123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SampleCode &#123; public static void main(String[] args) &#123; SampleCode sampleCode = new SampleCode(); Human human = new Human(); Human man = new Man(); Human woman = new Woman(); sampleCode.someOneSayHi(human); sampleCode.someOneSayHi(man); sampleCode.someOneSayHi(woman); human.sayHi(); man.sayHi(); woman.sayHi(); &#125; public void someOneSayHi(Human human) &#123; System.out.println("human say hi"); &#125; public void someOneSayHi(Man man) &#123; System.out.println("man say hi"); &#125; public void someOneSayHi(Woman woman) &#123; System.out.println("woman say hi"); &#125; public static class Human &#123; public void sayHi() &#123; System.out.println("I'm a human"); &#125; &#125; public static class Man extends Human &#123; @Override public void sayHi() &#123; System.out.println("I'm a man"); &#125; &#125; public static class Woman extends Human &#123; @Override public void sayHi() &#123; System.out.println("I'm a woman"); &#125; &#125;&#125; 在调用someOneSayHi()时，代码执行结果如下： 123human say hihuman say hihuman say hi 看代码，编译器是如何区分该调用哪个重载方法的呢，看这句 1Human man = new Man(); 这里Human表示man这个变量的静态类型，Man表示变量的实际类型。这两个类型在代码运行过程中都可以发生变化，静态类型仅在使用时发生变化，但是变量的类型并不会变化，同时最终的静态类型在编译器可知，实际类型则不同，需要到运行期才能确定。 从上可知，代码中的human、man、woman三个变量的静态类型都是Human，同时编译期可知，调用者又同为sampleCode，根据宗量数区分，调用哪个重载方法完全根据方法的静态类型来区分，可以判定调用someOneSayHi(Human human)这个重载方法。 动态分派在运行时根据变量的实际类型来确定是否向上转型调用子类方法的分派过程称为动态分派 在调用sayHi()时，代码执行结果如下： 123I'm a humanI'm a manI'm a woman 在判断调用子类还是父类方法时，如果只根据方法的静态类型来区分，无论如何都只会调用到父类的方法中。实际是根据子类不同调用的是不同子类中的覆写方法。 单分派和多分派多分派是指根据方法的宗量（方法的调用者和方法的参数）来判定调用哪个方法，当一个方法的调用有多于一个宗量时的分派叫做多分派。 根据上面的分析可以知道 对于重载方法，其判定的宗量有调用者这个动态类型和方法的参数两个宗量，java的静态分派是多分派。 对于覆写方法，其判定的宗量只有调用者（是父类还是子类）这个动态类型宗量，java是动态分派是单分派。 参考文献【深入Java虚拟机】之五：多态性实现机制——静态分派与动态分派]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Lambda表达式入门]]></title>
    <url>%2FJava8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A820180308%2F</url>
    <content type="text"><![CDATA[本文的目的在于快速的了解java 8 中lambda新特性，同时会对jdk中一些常用的api做介绍]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 基本命令行]]></title>
    <url>%2Fgit-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C20171212%2F</url>
    <content type="text"><![CDATA[本文主要对一些常用的git命令行进行了分类汇总初始化仓库1git init 文件添加到暂存区1git add test.txt 文件提交1git commit -m "test file commint" 文件删除1git rm test.txt 与远程仓库关联1git remote add origin git@server-name:path/repo-name.git 仓库地址替换123git remote rm origin（删除本地仓库关联的远端仓库地址）git remote add origin newUrl（添加新的仓库地址） push内容到远程分支123git push -u origin master (首次提交，将本地git默认创建的master分支跟远程代码库关联，并push)git push origin master（后续提交，如若远端没有这个分支，则自动新建分支） 版本回滚git reset 共有3种模式，分别是 git reset –mixed 保留现有工作区，但是会用指定的commit覆盖暂存区。 git reset –soft 保留暂存区，但是会清空工作区。 git reset –hard 简单粗暴，直接使用指定的commit的内容覆盖stage区以及工作区。 12345git reset --hard HEAD^ 回滚到上一版本git reset --hard HEAD^^ 回滚前到两个版本 git reset --hard 123456578 回滚到指定哈希值的版本号 撤销修改 尚未add的文件撤销修改 1git checkout -- test.txt (撤销当前工作区的修改，返回最新暂存区的内容) 针对于已经add到暂存区的文件 123git reset HEAD test.txt (回滚) git checkout -- test.txt (并丢弃) 针对已经commit，但是尚未push到远端的文件 1git reset --hard HEAD^ 回滚到上一版本 分支 查看当前分支 1git branch 新建分支 12345git checkout -b dev (新建并切换)git branch dev （新建分支）git checkout -b branch-name origin/branch-name(新建与远端对应的分支) 删除分支 1234567git branch -d devgit branch -D dev (忽略警告，强制删除)git fetch -p (删除没有远程对应分支的本地分支)git push --delete origin dev (删除远程分支) 切换分支 1git checkout master 合并分支(merge以及rebase两种) 123git merge dev (假设当前在master分支，则表示将dev合并到master上)git rebase dev(同上) 本地分支和远程分支做关联 1git branch --set-upstream dev origin/dev 拉取远端最新代码 1git pull tag管理 新建tag 1git tag v1.0.0 指定commit上添加tag 123git tag v1.0.0 xxxxxxgit tag -a v1.0.0 -m "add version 1.0.0 tag" xxxxxx (带提交的信息) 查看所有tag 1git tag 查看tag信息 1git show v1.0.0 删除tag 123git tag -d v1.0.0 （删除本地）git push origin :refs/tags/v1.0.0 (再删除远端的tag) push tag至远端 123git push origin v1.0.0 (push 指定tag)git push origin --tags (push所有tag) 获取远端tag 12345git fetch origin tag v1.0.0 (更新tag)git pull --tags (获取远端所有的tag)git pull --all (用于解决远端tag无法再本地显示的问题) 参考文献廖雪峰的官网-Git教程]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio如何将一个project引用为module]]></title>
    <url>%2FAndroid-Studio%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AAproject%E5%BC%95%E7%94%A8%E4%B8%BAmodule20171130%2F</url>
    <content type="text"><![CDATA[Project和Module的区别在Android Studio（以下简称：AS）中project中相当于eclipse的workspace也就是一个工作空间。在AS中Module就相当于一个单独项目App Module、Library Module以及Java Module的区别首先这三种module本质上没什么区别，主要区别在于AS在编译时根据不同的类型会生成不同的结果App Module编译生成apk文件，也就是我们的应用程序包。Java Module编译生成jar文件。Library Module编译生成aar文件，相对于jar文件，aar中包含有资源文件。如何将App Module转换成Libray Module引用新建两个project，如下图所示：新建完的project如下图所有，两个项目的app下build.gradle中可以看到类型都是“com.android.application”我们将需要被引用的project中的类型修改为library，如下图所示：接下来Sync一下，然后会得到一个如下错误提示：我们只需要把项目中的application id删除即可之后在主工程中import module选择我们修改好的project下的app文件夹，就是选中这个module导入因为主项目名也是app，这里直接使用app会有冲突，修改为自己喜欢的名字即可最后在主项目中的build.gradle中compile即可其他的问题swtich引起的问题，如下伪代码：1234567891011switch(id)&#123; case R.id.xxx: break; case R.id.yyy: break; case R.id.zzz: break; &#125; 这里在引用的时候就会报一个错误，提示id没有找到，这是因为引用的lib中id都不是final类型的，不能用在case中，这个时候只需要修改成 if() else() 的形式即可。对于大型项目的引用，这里的修就会比较繁琐。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码分析]]></title>
    <url>%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171130%2F</url>
    <content type="text"><![CDATA[什么是Retrofitretrofit 是Square公司为了方便网络请求，对自己okhttp底层网络请求进行了再一次封装的框架，意在简化网络请求调用。当然retrofit设计也并不单纯只为了okhttp服务，只是默认实现使用了okhttp。Retrofit的实现先来看retrofit的几个重要类RetrofitRetrofit adapts a Java interface to HTTP calls by using annotations on thedeclared methods to define how requests are made. Create instances using{@linkplain Builderthe builder} and pass your interface to {@link #create} to generate animplementation.通过动态代理的方式，解析方法申明上的注解来生成http请求。Retrofit实例主要充当一个适配器的角色。CallAn invocation of a Retrofit method that sends a request to a webserver andreturns a response.Each call yields its own HTTP request and response pair. Use {@link #clone}to make multiplecalls with the same parameters to the same webserver; this may be used toimplement polling or to retry a failed call.Retrofit方法的一个实现，向服务器发送一个请求，并返回一个响应保存了一对http的请求以及响应ConverterConvert objects to and from their representation in HTTP. Instances arecreated by {@linkplainFactory a factory} which is {@linkplainRetrofit.Builder#addConverterFactory(Factory) installed}into the {@link Retrofit} instance.对http响应进行转换，转换成请求接口需要的返回类型CallAdapterAdapts a {@link Call} with response type {@code R} into the type of {@codeT}. Instances arecreated by {@linkplain Factory a factory} which is{@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} intothe {@link Retrofit}instance.对请求进行适配，以满足接口要求ServiceMethodAdapts an invocation of an interface method into an HTTP call.将定义的网络请求方法适配成一个http callParameterHandlerServiceMethod解析参数时具体值保存的位置RequestBuilder构建一个初始的RequestRetrofit发起请求的过程先看一下调用的代码。Retrofit创建时使用的动态代理方式，中间的Platform就是根据不同的平台做了兼容。这里可以很清晰看到，对service进行代理，通过其中的method构建一个serviceMethod，进而new出okHttpCall,并使用serviceMethod内部持有的callAdapter对okHttpCall进行网路请求以及适配成用户期望的返回类型，完成一次网络请求。1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; ServiceMethod的构建 ServiceMethodg构建过程主要是对Service中定义的网络请求进行注解的解析处理，将完成的参数保存在ParameterHandler中以便后续取用，至于注解参数的获取比较琐碎，这里不做赘述。 CallAdapter的获取 1234567891011121314151617private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( "Method return type must not include a type variable or wildcard: %s", returnType); &#125; if (returnType == void.class) &#123; throw methodError("Service methods cannot return void."); &#125; Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, "Unable to create call adapter for %s", returnType); &#125; &#125; 这里开始用到了工厂模式，使用CallAdapter.Factory的方式来获取CallAdapter。我们知道在构建Retrofit时是可以addCallAdapterFactory的，这就意味着我们可以自己实现CallAdapter，提供给Retrofit使用，提高代码的扩展性。 通过遍历Retrofit中保存的CallAdapter.Factory列表获取到符合条件的Factory用做请求的转换。 通过上面代码可以知道，实际上获取到的时候是retrofit中默认初始化的CallAdapter 默认CallAdapter 在Retrofit build过程中可以看到如下代码 123456789 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); 通过平台的适配我们获取到的platform其实是如下Android平台 123456789101112131415161718static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125; &#125; 通过安卓平台可以初始化一个默认的ExecutorCallAdapterFactory，用以获取默认的CallAdapter。 通过ExecutorCallAdapterFactory可以get到一个CallAdapter的实现，并将Call适配成一个ExecutorCallbackCall，内部处理了网络请求以及线程的切换。 请求的梳理 通过上面的分析知道，默认的请求过程如下： 对Service进行动态代理 构建出ServiceMethod 通过ServiceMethod构建出OkHttpCall 通过ServiceMethod中的CallAdapter实际也就是ExecutorCallAdapterFactory，对OkHttpCall进行适配获取到我们所需要的Call对象 得到用户需要的Call之后就可以进行execute或者enqueue操作。 到这里基本的网络请求算是完了。 ·～～～～～～～～～～～～～～～～～～· ·～～～～～～～～～～～～～～～～～～· ·～～～～～～我是分割线～～～～～～～· ·～～～～～～～～～～～～～～～～～～· ·～～～～～～～～～～～～～～～～～～· 等等！是不是感觉漏掉了什么东西，前面提到的Converter好像用到。 开头说过Converter是对响应做了转换，那肯定是在Call中用到，那我们回过头去看OkHttpCall的构建。 OkHttpCall 主要看一下response的解析 123456789101112131415161718192021222324252627282930313233343536Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125; 我们来看这一句 1T body = serviceMethod.toResponse(catchingBody); 往上追溯到头可以知道，实际代码如下 1234567891011121314public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; checkNotNull(type, "type == null"); checkNotNull(annotations, "annotations == null"); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; 也就是我们常设置的GsonConverterFactory会在这里被取用，并对真正的response做解析。 至此一个完整的网络请求以及参数的解析都完整结束了 总结 Retrofit本身就是个适配器，用以协调资源 动态代码模式，每个请求都是动态生成 静态代理模式，如返回给我们的ExecutorCallbackCall，实际是对内部Call一个代理对象 builder模式，简化对象的构建 使用了工厂模式，同时提高了代码的定制性 适配器模式，将原始的响应适配成实际需要的类型]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码分析]]></title>
    <url>%2FEventBus3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171123%2F</url>
    <content type="text"><![CDATA[什么是EventBus根据官方介绍，eventbus是一个通过分布/观察者模式实现的消息总线，支持不同线程的调用，能极大的降低代码的耦合度。EventBus的设计先上图，官方介绍流程图如下也很简单，就是通过Publisher post事件到eventbus，之后发送给subscriber进行处理。很明显事件的分发处理在eventbus中，那我们就先从eventbus开始看起。EventBus实现实例获取方式如下，典型的单例模式：1234567891011/** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; 再来看一下构造方法： 1234567891011121314151617181920212223242526/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */ public EventBus() &#123; this(DEFAULT_BUILDER); &#125; EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 初始化一些成员变量，同时获取builder中的默认参数进行初始化。 上图是eventbus的成员变量，通过变量名不难知道，主要是做了3部分的缓存： 当前发送的eventTypes 事件类型作为Key，Subscription的List集合作为Value的Map集合 订阅者作为Key,订阅事件作为Value的Map集合 Subscriber的注册流程1234567891011121314151617/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 通过subscriberMethodFinder.findSubscriberMethods()获取到subscriberMethods，并进行了subscribe操作。 订阅方法的查找以及缓存操作1234567891011121314151617181920212223List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //先取缓存中的数据 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //这是3.0新增的属性，是否强制使用反射的方式获取订阅方法 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //这边如果没有配置自定义的MyEventBusIndex还是使用放射的方式获取 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 说一下里面的主要方法findUsingReflection（），这里通过反射的方式获取到有的注册过的方法，并查找父类同样注册过的方法。查找的方式也是比较简单: 获取到所有的public修饰的， 不包含Modifier.ABSTRACT、Modifier.STATIC、BRIDGE、SYNTHETIC中的修饰 只有一个注解就是Subscribe的方法，最后缓存在METHOD_CACHE中。我们来看具体的代码实现 12345678910private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //这里就是初始化了一个FindState，并通过while循环获取订阅类以及其父类的订阅方法，并做了缓存 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 主要的查找实现逻辑其实是在findUsingReflectionInSingleClass()中,也就是开始上面我们说的查找的规则，里面调用到的一个方法需要说一下，就是FindState.checkAddWithMethodSignature()这个方法 12345678910111213141516171819private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append('&gt;').append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); //这里判断了父类注册的方法是否被子类注册了 if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; 这个方法主要是判断了父类注册的方法是否被子类重写，如果被重写根据这个结果会抛出异常，限制了我们的子类去重写父类注册的方法。 注册事件监听以及注销上面说的方法的查询其实是注册的一部分，下面我们看方法查询完毕之后是怎么被注册上的。 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 很简单在subscribe()就是把查询出来的每个方法遍历操作，逐个生成Subscription，进行了缓存。 对重复注册的操作进行了抛出异常的处理，防止重复注册 在事件注册的同时还根据event注册时的优先级做了排序操作，之后缓存在内存中 对于sticky事件，这里在subscriber被注册时直接取出并交由subscriber进行了处理。 相对应的，在unregister()中，传入subscriber，将保存在subscriptionsByEventType已经typesBySubscriber中的缓存清除。 事件的发送1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125;``` 从当前线程中获取PostingThreadState，并将需要发送的event插入队列中。PostingThreadState中保存了一个事件的队列、是否正在发送消息、是否在主线程、当前发送的事件、当前需要同时的订阅对象以及是否取消等的参数。循环开启发送当个事件的操作，交由postSingleEvent()处理。```javaprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; 这里eventInheritance的一个操作就是是否获取事件的父类并做处理，如果需要则获取所有的父类，并依次处理。 接下来就是事件的发送了 1234567891011121314151617181920212223242526private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 这里就是一个循环操作，将之前以eventType为key保存的所有Subscription获取出来，并处理event的过程。 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125; &#125; 上面就是最后的事件的分发处理的逻辑了，根据注册时指定的线程类型，发送到对应的线程中进行处理。 到此整个Eventbus事件注册，以及发送处理的逻辑都完毕了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsBride源码分析]]></title>
    <url>%2FJsBridge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171122%2F</url>
    <content type="text"><![CDATA[近期做项目，想要做一套native和js交互的规范，在网上搜索了一番之后发现，JsBride相对比较火。本文就JsBride的实现流程做一个分析。1. 几个基本类123456781、BridgeWebView：Android端的一些必要的初始化在这里，入口在此2、BridgeWebViewClient：js的一些初始化，以及事件的拦截在此3、BridgeUtil：初始化以及交互数据解析的工具类4、Message：交互的数据bean5、BridgeHandler：js数据返回后的回调处理6、WebViewJavascriptBridge：向js发送消息7、WebViewJavascriptBridge.js:这个文件在assets下，初始化了js中的消息队列等8、CallBackFunction：具体的回调 2. 主要流程图 先看android调用js方法的时序图（图片源自网络）： 再看js调用android方法的时序图（图片源自网络）： 3. 源码分析 先从入口BridgeWebView开始看起，BridgeWebView的主要方法以及成员变量入下图: 主要的成员变量 123456public static final String toLoadJs = "WebViewJavascriptBridge.js";//用于js的初始化，指定assets下的文件 Map&lt;String, CallBackFunction&gt; responseCallbacks = new HashMap&lt;String, CallBackFunction&gt;();//根据方法名或者callbackStr保存的js调用native后的回调列表 Map&lt;String, BridgeHandler&gt; messageHandlers = new HashMap&lt;String, BridgeHandler&gt;();//根据注册的方法名保存的js调用处理的handler BridgeHandler defaultHandler = new DefaultHandler();//默认的js调用处理 private List&lt;Message&gt; startupMessage = new ArrayList&lt;Message&gt;();//在js loadFinish前发送的消息 初始化，主要就是最后一句，初始化了一个WebViewClient()，这个就是最开头提到的BridgeWebViewClient，具体里面实现，后面再做分析。 123456789private void init() &#123; this.setVerticalScrollBarEnabled(false); this.setHorizontalScrollBarEnabled(false); this.getSettings().setJavaScriptEnabled(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; this.setWebViewClient(generateBridgeWebViewClient());&#125; 注册native方法，注册方法很简单： 12345public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; messageHandlers.put(handlerName, handler); &#125;&#125; 以方法名为key，回调处理为value本地维护一个map 调用js注册的方法： 123public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack); &#125; 最终内部实际调用是loadurl的形式 实际js调用native流程分析12345678910111213function testClick1() &#123; var str1 = document.getElementById("text1").value; var str2 = document.getElementById("text2").value; var data = "name=" + str1 + ",pass=" + str2; //call native method window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': data &#125; , function(responseData) &#123; document.getElementById("show").innerHTML = "send get responseData from java, data = " + responseData &#125; ); &#125; 上面一段代码很简单，就是定义了一个方法，通过js来调用Native的submitFromWeb(),并传递了data参数，以及回调方法。通过源码可以看到，实际调用为 1234567891011//sendMessage add message, 触发native处理 sendMessage function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE; &#125; 这里自定义了协议头，同时保存了callback 以及相对应的id。实际发送的链接形式为：“yy://QUEUE_MESSAGE/“开头的形式 我们接着来看native是如何处理调用的： 在BridgeWebViewClient中 123456789101112131415161718@Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; url = URLDecoder.decode(url, "UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据 webView.handlerReturnData(url); return true; &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; // webView.flushMessageQueue(); return true; &#125; else &#123; return super.shouldOverrideUrlLoading(view, url); &#125; &#125; 这里可以知道，js过来的url为“yy://QUEUE_MESSAGE/“ 走webView.flushMessageQueue()分支。 看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void flushMessageQueue() &#123; if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // deserializeMessage List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Message m = list.get(i); String responseId = m.getResponseId(); // 是否是response if (!TextUtils.isEmpty(responseId)) &#123; CallBackFunction function = responseCallbacks.get(responseId); String responseData = m.getResponseData(); function.onCallBack(responseData); responseCallbacks.remove(responseId); &#125; else &#123; CallBackFunction responseFunction = null; // if had callbackId final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125; &#125; 这里开始真正进入数据传递以及回调的流程了，有点绕。 先看loadurl()，这里BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA，可以看到是调用了 1234567// 提供给native调用,该函数作用:获取sendMessageQueue返回给native,由于android不能直接获取返回的内容,所以使用url shouldOverrideUrlLoading 的方式返回内容 function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //android can't read directly the return data, so we can reload iframe src to communicate with java messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125; 用来把真正要传递的给native的数据传递过来。我们来看调用了_fetchQueue()之后发生了什么。 js重新组装了一个url，链接形式为“yy://return/_fetchQueue + encodeURIComponent(messageQueueString)” 可以在BridgeWebViewClient中的shouldOverrideUrlLoading()中，走的是 webView.handlerReturnData(url)分支，看这里是如何处理代码的 12345678910void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125; &#125; 可以看到，这里把我们之前获取js传递给native数据时缓存的responseCallback取了出来。在responseCallback就是真正的数据处理了。里面的主要处理就是，根据js过来的message数据，判断js是否需要在处理完数据后回调给他（根据responseId来判断），若需要则在CallBackFunction中定义Message，并在回调时加入message队列中，再次通过loadurl的形式传递给js并处理，处理逻辑如下 12345678910111213141516171819202122232425262728293031323334353637383940//提供给native使用, function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; //java call finished, now need to call js callback function if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; //直接发送 if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; //查找指定handler try &#123; handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception); &#125; &#125; &#125; &#125;); &#125; native调用js native调用js流程和上面基本一致，只是native在shouldOverrideUrlLoading()根据responseId能查询到callback并处理数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webview</tag>
      </tags>
  </entry>
</search>

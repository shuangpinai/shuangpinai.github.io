<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JsBride源码分析]]></title>
    <url>%2FJsBridge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171122%2F</url>
    <content type="text"><![CDATA[近期做项目，想要做一套native和js交互的规范，在网上搜索了一番之后发现，JsBride相对比较火。本文就JsBride的实现流程做一个分析。1. 几个基本类123456781、BridgeWebView：Android端的一些必要的初始化在这里，入口在此2、BridgeWebViewClient：js的一些初始化，以及事件的拦截在此3、BridgeUtil：初始化以及交互数据解析的工具类4、Message：交互的数据bean5、BridgeHandler：js数据返回后的回调处理6、WebViewJavascriptBridge：向js发送消息7、WebViewJavascriptBridge.js:这个文件在assets下，初始化了js中的消息队列等8、CallBackFunction：具体的回调 2. 主要流程图 先看android调用js方法的时序图（图片源自网络）： 再看js调用android方法的时序图（图片源自网络）： 3. 源码分析 先从入口BridgeWebView开始看起，BridgeWebView的主要方法以及成员变量入下图: 主要的成员变量 123456public static final String toLoadJs = "WebViewJavascriptBridge.js";//用于js的初始化，指定assets下的文件 Map&lt;String, CallBackFunction&gt; responseCallbacks = new HashMap&lt;String, CallBackFunction&gt;();//根据方法名或者callbackStr保存的js调用native后的回调列表 Map&lt;String, BridgeHandler&gt; messageHandlers = new HashMap&lt;String, BridgeHandler&gt;();//根据注册的方法名保存的js调用处理的handler BridgeHandler defaultHandler = new DefaultHandler();//默认的js调用处理 private List&lt;Message&gt; startupMessage = new ArrayList&lt;Message&gt;();//在js loadFinish前发送的消息 初始化，主要就是最后一句，初始化了一个WebViewClient()，这个就是最开头提到的BridgeWebViewClient，具体里面实现，后面再做分析。 123456789private void init() &#123; this.setVerticalScrollBarEnabled(false); this.setHorizontalScrollBarEnabled(false); this.getSettings().setJavaScriptEnabled(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; this.setWebViewClient(generateBridgeWebViewClient());&#125; 注册native方法，注册方法很简单： 12345public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; messageHandlers.put(handlerName, handler); &#125;&#125; 以方法名为key，回调处理为value本地维护一个map 调用js注册的方法： 123public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack); &#125; 最终内部实际调用是loadurl的形式 实际js调用native流程分析12345678910111213function testClick1() &#123; var str1 = document.getElementById("text1").value; var str2 = document.getElementById("text2").value; var data = "name=" + str1 + ",pass=" + str2; //call native method window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': data &#125; , function(responseData) &#123; document.getElementById("show").innerHTML = "send get responseData from java, data = " + responseData &#125; ); &#125; 上面一段代码很简单，就是定义了一个方法，通过js来调用Native的submitFromWeb(),并传递了data参数，以及回调方法。通过源码可以看到，实际调用为 1234567891011//sendMessage add message, 触发native处理 sendMessage function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE; &#125; 这里自定义了协议头，同时保存了callback 以及相对应的id。实际发送的链接形式为：“yy://QUEUE_MESSAGE/“开头的形式 我们接着来看native是如何处理调用的： 在BridgeWebViewClient中 123456789101112131415161718@Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; url = URLDecoder.decode(url, "UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据 webView.handlerReturnData(url); return true; &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; // webView.flushMessageQueue(); return true; &#125; else &#123; return super.shouldOverrideUrlLoading(view, url); &#125; &#125; 这里可以知道，js过来的url为“yy://QUEUE_MESSAGE/“ 走webView.flushMessageQueue()分支。 看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void flushMessageQueue() &#123; if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // deserializeMessage List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Message m = list.get(i); String responseId = m.getResponseId(); // 是否是response if (!TextUtils.isEmpty(responseId)) &#123; CallBackFunction function = responseCallbacks.get(responseId); String responseData = m.getResponseData(); function.onCallBack(responseData); responseCallbacks.remove(responseId); &#125; else &#123; CallBackFunction responseFunction = null; // if had callbackId final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125; &#125; 这里开始真正进入数据传递以及回调的流程了，有点绕。 先看loadurl()，这里BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA，可以看到是调用了 1234567// 提供给native调用,该函数作用:获取sendMessageQueue返回给native,由于android不能直接获取返回的内容,所以使用url shouldOverrideUrlLoading 的方式返回内容 function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //android can't read directly the return data, so we can reload iframe src to communicate with java messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125; 用来把真正要传递的给native的数据传递过来。我们来看调用了_fetchQueue()之后发生了什么。 js重新组装了一个url，链接形式为“yy://return/_fetchQueue + encodeURIComponent(messageQueueString)” 可以在BridgeWebViewClient中的shouldOverrideUrlLoading()中，走的是 webView.handlerReturnData(url)分支，看这里是如何处理代码的 12345678910void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125; &#125; 可以看到，这里把我们之前获取js传递给native数据时缓存的responseCallback取了出来。在responseCallback就是真正的数据处理了。里面的主要处理就是，根据js过来的message数据，判断js是否需要在处理完数据后回调给他（根据responseId来判断），若需要则在CallBackFunction中定义Message，并在回调时加入message队列中，再次通过loadurl的形式传递给js并处理，处理逻辑如下 12345678910111213141516171819202122232425262728293031323334353637383940//提供给native使用, function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; //java call finished, now need to call js callback function if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; //直接发送 if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; //查找指定handler try &#123; handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception); &#125; &#125; &#125; &#125;); &#125; native调用js native调用js流程和上面基本一致，只是native在shouldOverrideUrlLoading()根据responseId能查询到callback并处理数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webview</tag>
      </tags>
  </entry>
</search>

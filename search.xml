<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java类的初始化]]></title>
    <url>%2FJava%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%9620180710%2F</url>
    <content type="text"><![CDATA[之前整理了《JVM之类加载机制》的文章，对于一个类的初始化阶段介绍太过简略，这里再开一篇文章，着重介绍类的初始化流程。类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的Java程序代码。虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类，也就是main方法所在的类。这里再说一下类不被初始化的情况：对于静态字段（没有final修饰），只有直接定义这个字段的类才会被初始化，子类调用父类的静态字段并不会触发子类的初始化static final 修饰的常量，在编辑时就存入了调用者的Class文件常量池中，调用时并不会触发定义类的初始化，也就是这个常量已经使用的类绑定。数组初始化过程并不会触发引用类的初始化类或接口初始化编译器自动收集类变量赋值以及静态代码块后自动合并生成类的&lt;clint&gt;()，类开始初始化时会为static变量赋上零值。&lt;clint&gt;()对于类和接口来说这个方法并不是必须的。&lt;clint&gt;()中，静态语句只能访问定义在它之前定义的静态变量，定义在它之后的静态变量，可以赋值，但不能访问。子类&lt;clint&gt;()不需要显示的调用父类的构造器，JVM保证子类的&lt;clint&gt;()执行之前，父类的&lt;clint&gt;()已经执行完毕。由于父类的&lt;clint&gt;()先执行，所以父类的静态语句优先与子类的静态语句执行先对类，接口的执行&lt;clint&gt;()时并不需要执行父接口的&lt;clint&gt;()方法，只有使用父接口定义的变量时，父接口才会初始化。接口的实现类初始化时也不会调用接口的&lt;clint&gt;()JVM保证一个类的&lt;clint&gt;()执行时线程安全的，多线程执行类的&lt;clint&gt;()时只能有一个被执行，其余线程等待（执行完毕后其他线程不再进入&lt;clint&gt;()）。如果一个类的&lt;clint&gt;()执行耗时操作，可能会造成多进程阻塞这里还有几个注意点：接口也有初始化过程，在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成&lt;clint&gt;()，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）。二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化类变量的赋值下面简要说明下final、static、static final修饰的字段赋值的区别：static修饰的字段在类加载过程中的准备阶段被初始化为0或null等默认值，而后在初始化阶段（触发类构造器&lt;clint&gt;()）才会被赋予代码中设定的值，如果没有设定值，那么它的值就为默认值。final修饰的字段在运行时被初始化（可以直接赋值，也可以在实例构造器中赋值），一旦赋值便不可更改；static final修饰的字段在Javac时生成ConstantValue属性，在类加载的准备阶段根据ConstantValue的值为该字段赋值，它没有默认值，必须显式地赋值，否则Javac时会报错。可以理解为在编译期即把结果放入了常量池中。实例对象的初始化编译器自动收集实例变量初始化以及实例代码块后自动合并生成类的&lt;init&gt;()子类初始化时会先调用父类&lt;init&gt;()，用以保证子类能正常初始化。执行子类的&lt;init&gt;()那么从上面可以知道，一个类在初始化过程中，构造方法的执行过程如下：父类的&lt;init&gt;()子类的&lt;init&gt;()父类的&lt;init&gt;()子类的&lt;init&gt;()举个栗子验证一下1234567891011121314151617181920212223242526public class ClassInitTest &#123; public static void main(String[] args) &#123; new Child(); &#125; public static class Parent &#123; static &#123; System.out.println("Parent static code"); &#125; public Parent() &#123; System.out.println("Parent constructor code"); &#125; &#125; public static class Child extends Parent &#123; static &#123; System.out.println("Child static code"); &#125; public Child() &#123; System.out.println("Child constructor code"); &#125; &#125;&#125; 打印如下： 1234Parent static codeChild static codeParent constructor codeChild constructor code]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之内存区域划分]]></title>
    <url>%2FJVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%8620180708%2F</url>
    <content type="text"><![CDATA[JVM在执行Java过程中会把它所管理的内存划分为一下几个运行时数据区域：程序计数器Java虚拟机栈本地方法栈Java堆方法区程序计数器程序计数器是一块内存较小的空间，可以看作是当前线程执行的字节码的行号指示器，是每个线程私有的内存区域。当前线程执行的是java方法时，计数器记录的是正在执行的虚拟机字节码指令的地址当前线程执行的是Native方法时，计数器为空程序计数器计数器是JVM规范中唯一没有规定任何OOM的区域Java虚拟机栈Java虚拟机栈也是线程私有的，生命周期与线程相同。Java虚拟机栈描述的是Java方法执行的内存模型：每一个方法创建时会创建一个栈帧，每一个方法从开始调用到执行完成过程，对应着一个栈帧在虚拟机栈中的入栈和出栈的过程。上面提到的栈帧是方法运行时的基础数据结构，用于存储局部变量表操作数栈动态链接方法出口等信息。通常人们将Java内存分为堆内存和栈内存，这里所指的栈内存就是指的虚拟机栈或者说是虚拟机栈中局部变量表。局部变量表存放着各种编译期可知数据：各种基本数据类型（boolean、byte、char、short、int、float、long、double）对象引用（reference类型，并不等同于对象，可能是指向对象起始地址的引用指针或者指向代表一个对象的句柄）returnAddress（一条字节码指令地址）局部变量表存储数据的单位为slot（局部变量空间），其中64位长度的long和double占用2个slot，其余数据类型都占用一个slot。局部变量表所需要的内存在编译期就分配完成，当一个方法进入虚拟机栈时，所需要分配的局部变量空间（slot）时确定的，方法运行期间并不会改变局部变量表大小。这里插播一条JVM对对象的访问：java通过reference 数据来操作堆上的具体对象，目前流行的对象的访问方式有两种：句柄和直接指针。如果使用句柄访问的话Java堆会划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址。好处是reference存储的是稳定的句柄地址，对象被移动时reference本身并不需要改动如果使用直接指针形式，reference中存储的直接就是使用对象。好处是速度快，节省一次执行定位的开销这块区域会抛出两种异常分别是StackOverFlowError以及OutOfMemoryError：当线程请求的栈的深度大于虚拟机栈的深度时会抛出StackOverFlowError。这个异常通常是单线程情况下发生的若虚拟机栈可以动态扩展，在扩展过程中无法申请到足够内存时，抛出OutOfMemoryError。这个异常一般发生在多线程环境。鉴于上面2点，当虚拟机栈中由于线程创建过多导致的OutOfMemoryError问题时，可以适当的调整单个线程的大小以增加线程个数。本地方法栈本地方法栈与虚拟机栈相似，只不过本地方法栈时位Native方法服务的。同理这块内存区域也会抛出StackOverFlowError以及OutOfMemoryError异常Java堆内存堆内存是JVM管理的最大的一块内存区域，此区域存在的目的唯一目的就是存放实例对象，几乎所有的实例对象都在此分配内存，这块内存是所有线程共享的。由于堆内存是垃圾收集器管理的主要区域，通常情况下Java堆又被称为GC堆。当对象分配内存过程，如果堆内存没有足够的内存空间完成实例分配时，抛出OutOfMemoryError异常。方法区方法区与堆内存一样是所有线程共享的，用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在Hotspot虚拟机下，通常方法区被称为“永久代”。运行时常量池运行时常量池是方法区的一部分，Class文件中用于存储编译期生成的各种字面量和符号引用的常量池在类被加载后，将进入运行时常量池进行存储。除了Class文件中的符号引用被爆存在运行时常量池中，一般情况下，被翻译出来的直接引用也将存储在运行时常量池中。运行时常量池具备动态特性，除了编译期产生的常量，运行期也可以将新的常量放入池中。当运行时常量池无法在方法区申请到足够内存时，也会抛出OutOfMemoryError异常。直接内存直接内存并不是JVM运行时数据的一部分。在JDK1.4版本中引入了NIO（New Input/Output）类，可以使用Native函数库直接分配堆外内存，通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，从而避免在Java堆中和Native堆中来回复制数据。这个内存区域也会抛出OutOfMemoryError异常。常量池分类常量池概念有几个点，这里单独区分一下：全局字符串池：这里保存的全局共享的字符串的引用，并不直接保存字符串Class文件常量池：java文件编译成.class文件后就会生成常量池，用于保存编译产生的字面量和符号引用（这里存放的只是引用）。注意：static final常量在编译期就将其结果放入了调用它的类的常量池中运行时常量池：运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。这个常量池，每个类实例对象都能引用到。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性参考书籍本文摘录、整理自周志明的《深入理解Java虚拟机》一书，如想获得更详细介绍可自行查阅此书。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之类加载机制]]></title>
    <url>%2FJVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B620180702%2F</url>
    <content type="text"><![CDATA[一个Java类从被加载到虚拟机内存到被卸载出内存为止，生命周期一共包括如下几个阶段：加载（Loading）验证 (Verfication)准备 (Preparation)解析 (Resolution)初始化 (Initialization)使用 (Using)卸载 (Unloading)其中验证、准备、解析这个3个部分统称为链接（Linking）。加载、验证、准备、初始化和卸载这5个阶段开始执行的顺序是一定的，但不意味着这几个阶段是分开执行的，这些阶段通常是相互交叉混合式进行的，通常会在一个阶段执行的过程中调用、激活另一个过程。解析阶段则不一定，为了支持java的运行时绑定，在某些特定的情况下解析可以在初始化阶段之后开始。加载阶段这个阶段主要完成如下3件事情通过一个类的全限定名来获取定义此类的二进制字节流将这个字节流代表的静态存储结构转化成方法区的运行时数据结构生成一个此类的Java.lang.Class对象（方法区中），作为方法区这个类的数据的访问入口。这里获取字节流的方式并不局限于zip，还包括诸如网络中获取、运行时生成、其他文件生成、数据库读取等方式。同时相对于类加载过程的其他阶段，相对于一个非数组类的加载阶段是开发者可控性最强的，因为加载阶段既可以使用系统提供的加载器，也可以用户自定义类加载器来完成类的加载。数组类的加载情况有所不同，虽然数组类是JVM直接创建的，但是数组的组件，最终还是要依靠类加载器去加载，一个数组类创建主要有如下几点：如果数组的组件类型为引用类型，数组将会在组件的类加载器上被标识。如果组件类型不是引用类型，JVM会将数据将会与引导类加载器关联。数组的可见性与它的组件类型保持一致，如果组件的类型不是引用类型，则数据可见性默认为public。加载阶段完成后，类的二进制字节流将按照JVM所需的格式存储在方法区中，同时在内存中实例化一个java.lang.Class的实例对象，作为程序访问方法区中这些类数据的外部接口。相对于HotSpot，这个实例对象比较特殊，虽然是一个对象，但并没有放置在堆中，而是放置在方法区中。验证阶段这个阶段主要是确保加载的Class文件中的字节流包含的信息符合当前虚拟机的要求，同时不存在损害JVM的行为.从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证文件格式验证这一阶段主要验证字节流是否符合Class文件格式的规范：验证开头的4字节的Magic Number 是否是0xCAFEBABE检验当前的主、次版本号能否能被当前虚拟机处理常量池中是否有不被支持的常量类型指向常量的各种索引值是否有不存在或者不符合类型的常量CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据Class文件的各个部分以及文件本身是否被删除或者附带其他信息以及等等一些步骤，通过这个步骤的验证之后，字节流才会进入方法区中存储，后续的3个阶段的验证，都是基于方法区的存储结构进行的元数据验证这一阶段主要是对字节码描述的信息进行语义分析：是否有父类（只有Object没有父类）它的父类是否继承了不允许被继承的类（被final修饰的类）非抽象类是否实现了父类要求实现的方法成员变量、方法等是否与父类相矛盾（覆盖父类final字段，重载的方法是否符合要求）等等字节码验证这一阶段将对类的方法体进行校验分析，保证类的方法在运行时不会做出危害虚拟机安全的事件。这个阶段是整个验证过程中最复杂的一个阶段保证任意时刻操作数栈的数据类型都能和指令代码序列配合工作保证跳转指令不会跳转到方法体之外的指令保证方法体中的类型转换是有效的等等没有通过字节码验证的方法体一定是有问题的，但是通过字节码验证的方法体也不能保证一定没问题。符号引用验证这个验证发生在JVM将符合引用转换成直接引用的时候，在链接的第三阶段—解析阶段发生符合引用通过字符串描述的全限定名能否找到对应的类指定类中是否存在符合方法的字段描述以及简单名称所描素的方法和字段符号引用的类、字段、方法是否能被当前类访问等等验证阶段对于JVM的类加载机制是非常重要的，但不是必要的，因为对程序运行期没有影响准备阶段这个阶段主要是为类变量（也就是被static修饰的）分配内存并赋值零值的阶段。所谓的零值就是默认的初始值，每种数据类型各有不同的零值。（需要注意的是同时被static final 修饰的变量在此时就赋值完毕，并不会存在赋零值的操作）举个栗子：12public static int abc = 123;public static final int ABC = 123; 上面两句的代码在准备阶段的区别是 准备阶段过后，变量abc的初始值是0，而不是123。被static修饰的变量赋值操作，被JVM收集后存在于类构造器的()中，这里还没执行到类的初始化阶段，所以并不会被赋值成123； 同时被static final 修饰的变量ABC在编辑阶段javac就会为ABC生成ConstantValue属性，在准备JVM就会根据ConstantValue直接赋值，也就是准备阶段后ABC的值为123； 解析阶段这个阶段主要是将字节码文件中的符号引用转化为直接引用，这个阶段发生的时间段并不确定，某些情况下解析可以发生在初始化阶段之后，这是为了支持Java语言的运行时绑定。JVM可以根据需求来判断到底要在类被加载器加载的时候就对常量池中的符号引用进行解析，还是等到另一个符号引用将要被使用的时候去解析。 符号引用：符合引用是以一组符号来描述所引用的目标，符号可以可是以任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用的对象并不一定加载到内存中 直接引用：直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。相对于符号引用，被直接引用的对象一定已经加载到内存中。 解析主要针对类或接口、字段、类方法、类接口、接口方法、方法类型、方法句柄和调用点限定符7种符号引用，这里主要讲前面4种。 类或接口的解析假设在类D中要把一个未解析过的符号引用N解析为对一个类或接口C的直接引用，JVM有如下操作： C是非数组类型，JVM通过N代表的全限定名传递给D的类加载器去加载C。此过程中可能出去C继承的父类或实现的接口的加载 C是数组类型，同时元素类型是引用类型，通过上面步骤去加载数组元素的引用类型，并由JVM生成一个代表数组C维度和元素的数组对象 解析完成之后进行符号引用验证，确认D对C的引用权限 字段解析解析一个字段符号引用，会先对字段所属的类或者接口的符号引用先进行解析。解析到所属的类或接口C后JVM按照如下规范对字段进行搜索： 若C中包含了简单名称和字段描述都符合的字段，则返回这个字段的直接引用 若C中实现了接口，则按照继承关系从下往上搜索各个接口及其父接口，如匹配到简单名称和字段描述都一致的字段，则返回该字段的直接引用 若C不是java.lang.Object，按照继承关系从下往上搜索父类，如匹配到简单名称和字段描述都一致的字段，则返回该字段的直接引用 查找失败，抛出java.lang.NoSuchFieldError 解析完成后对字段进行权限验证 类方法解析与字段解析一样，解析一个类方法也是要先解析到这个方法所属的类或者接口。解析到所属的类或接口C后JVM按照如下规范对字段进行搜索： 若解析发现C是一个接口，则抛出异常 剩余步骤和字段解析一致，不再赘述 接口方法解析与类方法解析相比较： 若解析返现C是一个类，则抛出异常 由于接口中所有的方法都是public的，省去权限校验这一步骤 初始化阶段类的初始化是类加载过程的最后一步，到了初始化阶段才开始真正执行java代码 这个阶段会执行类的&lt;clint&gt;()，为类变量进行显示的赋值操作。类的&lt;clint&gt;()是编译器自动收集类变量以及静态代码块后自动合并生成的。 &lt;clint&gt;()对于类和接口来说这个方法并不是必须的。 &lt;clint&gt;()中，静态语句只能访问定义在它之前定义的静态变量，定义在它之后的静态变量，可以赋值，但不能访问。 子类&lt;clint&gt;()不需要显示的调用父类的构造器，JVM保证子类的&lt;clint&gt;()执行之前，父类的&lt;clint&gt;()已经执行完毕。 由于父类的&lt;clint&gt;()先执行，所以父类的静态语句优先与子类的静态语句执行 先对类，接口的执行&lt;clint&gt;()时并不需要执行父接口的&lt;clint&gt;()方法，只有使用父接口定义的变量时，父接口才会初始化。接口的实现类初始化时也不会调用接口的&lt;clint&gt;() JVM保证一个类的&lt;clint&gt;()执行时线程安全的，多线程执行类的&lt;clint&gt;()时只能有一个被执行，其余线程等待（执行完毕后其他线程不再进入&lt;clint&gt;()）。如果一个类的&lt;clint&gt;()执行耗时操作，可能会造成多进程阻塞 使用阶段这个没啥好说的，只要代表类的Class对象还能被引用到，类就还在使用当中。 卸载阶段一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。类的卸载，其实就是方法区中的类的回收。判断一个类是否可以进行回收，需要同时满足下面3个条件： 该类所有的实例对象都已经被回收，java堆中不存在任何该类的实例对象 加载该类的ClassLoader已经被回收 该类的java.lang.Class对象没有在任何地方被引用到，无法在任何地方通过反射访问到该类的方法。 上面条件仅仅说明该类可以进行回收，但是并不想类的实例对象一样，不使用了就立马进行回收。 如上图所示，当左侧所有的引用都消失时，类可以被回收。 Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。由用户自定义的类加载器加载的类是可以被卸载的。 参考书籍本文摘录、整理自周志明的《深入理解Java虚拟机》一书，如想获得更详细介绍可自己查阅此书。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashTable简介]]></title>
    <url>%2FHashTable%E7%AE%80%E4%BB%8B20180613%2F</url>
    <content type="text"><![CDATA[之前写了HashMap的实现原理，因为HashTable实现和HashMap区别并不大，之前偷懒没有再写HashTable的实现，近期发现了一些其他的区别，这里再做一次补充。不知道HashMap实现原理的同学可以先这个：HashMap实现原理，其中多数重复的实现原理就不再赘述了，本文着重分析两者的区别。HashTable的实现HashTable继承自Dictionary，Dictionary是任何保存键值对的类的父类，不过这个类已经过时了。HashMap中继承的是AbstractMap与HashTable有所不同。与HashMap一致，HashTable也是通过数组和链表存储数据。table, count, threshold, loadFactor这些成员变量都与HashMap作用相同。数据的遍历、存放等方法都可以在HashMap中看到，这里就不再细说。主要说一下两者的区别：HashMap可以存储value为null的值，同时key也可以为null，HashTable不行HashTable基本上所有的方法都加了synchronized，线程安全，HashMap线程不安全，不过我们可以通过Collections.synchronizedMap()来获取一个包装后线程安全的mapHashtable比HashMap多提供了elments() 和contains() 两个方法。HashTable默认的容量是11，每次扩容2n+1，HashMap初始值为4，每次扩容2n计算key存放位置的方法不同，HashMap效率高，但是冲突更严重这里着重讲一个两者的区别HashMap：12345678910int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);int i = indexFor(hash, table.length);/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1); &#125; Hashtable: 123456int hash = hash(key);int index = (hash &amp; 0x7FFFFFFF) % tab.length;private static int hash(Object k) &#123; return k.hashCode(); &#125; 可以看到，Hashtable在得到hash之后有进行了一次取余操作，这比较耗时。HashMap因为从一开始就保证了容量为2的幂次放，在得到hash后直接进行了位移运算，这相对Hashtable效率高。但是Hashtable这样做也是有好处的，那就是数据能更离散的存放在table中。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-DiffUtil以及最新ListAdapter介绍]]></title>
    <url>%2FAndroid-DiffUtil%E4%BB%8B%E7%BB%8D20180601%2F</url>
    <content type="text"><![CDATA[本文主要介绍Android系统中提供的工具类DiffUtil，DiffUtil的主是用与RecyclerView的局部更新，从而提高页面刷新效率。本文基于最新的v7-27.1.1版本的RecyclerView做介绍，因为这个兼容包里面新增了一个ListAdapter，一并做介绍。DiffUtilDiffUtil是在安卓7.0上引入的工具类，相对于“传统”的nofityDataChange()方式：DiffUtil可以让我们做到数据局部刷新。虽然我们也可以手动去记录数据改变的位置，自己通过notifyItemRangeInserted等方法去更新数据，但是麻烦～DiffUtil可以在局部数据刷新的时候显示动画。先上demo，看一下DiffUtil要怎么用简易用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static final class MyDiffUtilCallback extends DiffUtil.Callback &#123; private List&lt;Bean&gt; mOldList; private List&lt;Bean&gt; mNewList; public MyDiffUtilCallback setDates(List&lt;Bean&gt; oldList, List&lt;Bean&gt; newList) &#123; mOldList = oldList; mNewList = newList; return this; &#125; @Override public int getOldListSize() &#123; return mOldList.size(); &#125; @Override public int getNewListSize() &#123; return mNewList.size(); &#125; @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) &#123; return mOldList.get(oldItemPosition).id == mNewList.get(newItemPosition).id;// return true; &#125; @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) &#123; return mOldList.get(oldItemPosition).content.equals(mNewList.get(newItemPosition).content); &#125; &#125; ... public void onNewData(List&lt;Bean&gt; newData) &#123; //数据源太大时计算费时，放入子线程 //最新版本兼容包已出ListAdapter，自带子线程执行 DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(mMyDiffUtilCallback.setDates(mBeans, newData)); diffResult.dispatchUpdatesTo(MyAdapter.this); mBeans.clear(); mBeans.addAll(newData); &#125; 上面的代码很简单： 就是实现DiffUtil.Callback，指定数据差异的规则 在有新数据时，通过DiffUtil.calculateDiff(Callback cb)计算新老数据的差异 将计算完的结果更新到adapter中 我们可以看到DiffUtil.Callback主要有4个抽象方法需要实现，看一下这4个方法的具体作用。 12public abstract int getOldListSize(); public abstract int getNewListSize(); 上面2个方法主要获取新老数据的长度。 1234//返回值表示新数据传入时这两个位置的数据是否时同一个条目 public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition);//返回值表示新老位置的数据内容是否相同，这个方法在areItemsTheSame（）返回true时生效 public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition); 上面这两个方法就是区分两个数据bean是否相同。 敲黑板，这里有个注意点： 当areItemsTheSame返回为false时，不管areContentsTheSame是否为true，adapter中的条目都会更新 高级用法DiffUtil.Callback中还有另外一个可以复写的方法 1234@Nullable public Object getChangePayload(int oldItemPosition, int newItemPosition) &#123; return null; &#125; 当areItemsTheSame()返回true，同时areContentsTheSame()返回false时，通过这个方法可以用来返回具体的数据差异。 我们来看一下用法 1234567891011121314151617181920212223242526272829@Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) &#123; return mOldList.get(oldItemPosition).id == mNewList.get(newItemPosition).id; return true; &#125; @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) &#123; return false;&#125; @Nullable @Override public Object getChangePayload(int oldItemPosition, int newItemPosition) &#123; Bean oldBean = mOldList.get(oldItemPosition); Bean newBean = mNewList.get(newItemPosition); Bundle bundle = new Bundle(); if (!oldBean.content.equals(newBean.content)) &#123; bundle.putString("content", newBean.content); &#125; if (bundle.size() &gt; 0) &#123; return bundle; &#125; return null; &#125; 然后在Recycler的Adapter中我们通过onBindViewHolder()的另一个重载方法获取到之前设置的数据进行局部刷新。 12345678910111213141516@Override public void onBindViewHolder(MyAdapter.ViewHolder holder, int position, @NonNull List payloads) &#123; if (payloads.isEmpty()) &#123; super.onBindViewHolder(holder, position, payloads); //内部其实就是调用的全部刷新的方法 //onBindViewHolder(holder, position); &#125; else &#123; Bundle bundle = (Bundle) payloads.get(0); for (String key : bundle.keySet()) &#123; if (key.equals("content")) &#123; holder.contentView.setText(bundle.getString("content")); &#125; &#125; &#125; &#125; 好了，这里就是DiffUtil的用法了，实现其中的Callback用户比较数据的差异，当来新数据时，调用其中的calculateDiff()静态方法计算数据差异即可。如果你想实现RecyclerView的局部刷新，那可以实现getChangePayload。 ListAdapter当数据量不大时，我们可以在UI线程中直接更新数据，但是当数据量大时这就比较尴尬了，我们需要自己放在子线程操作，然后再回UI线程更新页面。 在7.0上引入DiffUtil之后，现在又在最新的v7的27.1.1兼容包中加入的官方的支持，就是ListAdapter。 1234567891011121314151617181920212223242526272829303132333435363738public abstract class ListAdapter&lt;T, VH extends RecyclerView.ViewHolder&gt; extends RecyclerView.Adapter&lt;VH&gt; &#123; private final AsyncListDiffer&lt;T&gt; mHelper; @SuppressWarnings("unused") protected ListAdapter(@NonNull DiffUtil.ItemCallback&lt;T&gt; diffCallback) &#123; mHelper = new AsyncListDiffer&lt;&gt;(new AdapterListUpdateCallback(this), new AsyncDifferConfig.Builder&lt;&gt;(diffCallback).build()); &#125; @SuppressWarnings("unused") protected ListAdapter(@NonNull AsyncDifferConfig&lt;T&gt; config) &#123; mHelper = new AsyncListDiffer&lt;&gt;(new AdapterListUpdateCallback(this), config); &#125; /** * Submits a new list to be diffed, and displayed. * &lt;p&gt; * If a list is already being displayed, a diff will be computed on a background thread, which * will dispatch Adapter.notifyItem events on the main thread. * * @param list The new list to be displayed. */ @SuppressWarnings("WeakerAccess") public void submitList(List&lt;T&gt; list) &#123; mHelper.submitList(list); &#125; @SuppressWarnings("unused") protected T getItem(int position) &#123; return mHelper.getCurrentList().get(position); &#125; @Override public int getItemCount() &#123; return mHelper.getCurrentList().size(); &#125;&#125; ListAdapter用法就跟普通的RecyclerView并无太大差别。 一共2个构造方法，区别在于第二个构造方法可以自己指定执行的线程。 submitList(),用于提交新数据，更新UI。 数据比较操作的线程操作在AsyncListDiffer中实现，代码也比较简单，这里就不再贴代码分析了。需要注意点一点时，通过AsyncListDiffer返回的List是一个UnmodifiableList，意味着不能改变长度。 总结时间 DiffUtil提供了梅耶斯算法实现的新老数据比较的方法，数据比较的规则在Callback中让用户自行实现，同时实现getChangePayload配合Adaper中的onBindViewHolder(MyAdapter.ViewHolder holder, int position, @NonNull List payloads)可以实现数据的局部更新。 ListAdapter是对RecyclerView传统Adapter的一个拓展，在子线程中利用DiffUtil比较数据，并在UI线程更新。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-AsyncTask讲解]]></title>
    <url>%2FAndroid-AsyncTask%E8%AE%B2%E8%A7%A320180514%2F</url>
    <content type="text"><![CDATA[AsyncTask就是安卓中一个对线程池的典型的应用，其中还涉及了之前博文中介绍的FutureTask等知识点，本文主要对AsyncTask源码做一次讲解官方介绍上面截图就是官方对AsyncTask的介绍，内容比较多就不逐字逐句翻译了，挑几个重要的解释一下。AnsycTask主要目的是执行短时间的操作，其他的任务更推荐使用线程池AnsycTask定义了后台计算的方法，同时结果更新在UI线程，定义了Params、Progress、Result分别用于表示执行参数、进度参数以及结果，不需要某个参数时可以用Viod。使用过程相关的方法主要有如下几个：onPreExecute()：主要用于一些计算前的数据准备，在UI线程被调用。doInBackground(Params…)：后台计算的方法，子线程中调用，一般在此方法调用publishProgress(Progress… values)用于更新进度等操作，在子线程调用。onProgressUpdate(Progress…)：后台操作进度的更新到UI上，在UI线程中调用onPostExecute(Result)：计算结果的返回，在UI线程调用。AnsycTask执行过程中可以取消，取消的形式和FutureTask一致AnsycTask实例只能在UI线程被创建，同时execute(Params…) 也只能在UI线程被调用，并且只能被调用一次，多次调用抛出异常。多个AnsycTask实例对象分别调用execute(Params…)也是被同步执行的，这点比较坑，因为内部用的默认线程池是静态定义的，并且是同步的调用AnsycTask的静态方法 execute (Runnable runnable)，多个runnable也是同步执行的调用AnsycTask的成员方法executeOnExecutor (Executor exec, Params… params)可指定任务执行的线程池，一般推荐调用系统默认实现的THREAD_POOL_EXECUTOR线程池。这样可以多个实例并行执行。上面差不多就是AnsycTask的重点了下面就源码做一次解析。先从线程池开始说起，与多线程相关的主要就是THREAD_POOL_EXECUTOR和sDefaultExecutor这个两个线程池。THREAD_POOL_EXECUTOR1234567static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; &#125; 之前博文中有介绍的，这个构建出来的线程池拥有的核心线程数是CORE_POOL_SIZE，最大线程数是MAXIMUM_POOL_SIZE，任务队列是sPoolWorkQueue，线程构建通过sThreadFactory，非核心线程存活时间为KEEP_ALIVE_SECONDS 核心线程的计算如下： 1234// We want at least 2 threads and at most 4 threads in the core pool, // preferring to have 1 less than the CPU count to avoid saturating // the CPU with background work private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); 最多为cpu核心的个数-1个。 任务队列构建如下： 12private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); 可以看到最多为128个任务。 SerialExecutor这个就是不指定线程池时任务默认处理用的线程池，来看一下里面的实现 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 内部很简单，将传递进来的任务保存在新的Runnable中并入队，等待被执行。 这个执行的过程时通过scheduleNext()来控制的，可以看出队列里任务都是等上一个任务执行完毕后再执行下一个任务实现了串行的效果。 SerialExecutor实例对象在AsyncTask中以静态变量的形式存在，这意味着所有的子类共用这个默认的线程池，这也是为什么开头说的多个子类实例执行也是串行的原因所在。 构造方法AsyncTask开始构造时，会初始化两个成员变量mWorker和mFuture， mWorker将耗时操作放在此执行，并将结果传递下去 mFuture包装mWorker，传递给线程池执行，并处理结果 任务执行状态的区分主要靠这两个变量，我们来看一下源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public AsyncTask() &#123; //其实是一个Callable mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; WorkerRunnable本质上是一个Callable，配合下面的FutureTask，可以让线程池执行之后获取对应的结果。 上面的代码也可以看到一点点端倪，看AsyncTask是怎么执行代码的： mWorker开始的时候就mTaskInvoked状态置为了true（防止结果无法被处理）同时在当前线程调用了doInBackground()，保存了结果。 在将结果往下传递的过程中先判断了任务是否被中断，若任务被中断，则mCancelled置为true。 mFuture获取结果，通过不同的状态讲结果处理。 任务的开启上面说了任务的构造，这里说说任务的开启，先上代码 1234567891011121314151617181920212223242526272829@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125;@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; 这两个方法都在UI线程调用，其中不指定执行线程池时，默认使用AsyncTask内部实现的SerialExecutor线程池。 这里可以看到对任务的多次执行以及完成的任务再次执行都会抛出异常。 任务开启后调用了onPreExecute()，接着执行构造方法里面初始化的mFuture，上面我们分析过会调用doInBackground(),同时会根据不同状态处理结果，这样任务的开始后的逻辑就可以撸顺了。 任务执行静态方法上面提到了2个任务执行的实例对象方法，AsyncTask中还存在一个静态方法execute(Runnable runnable) 1234@MainThread public static void execute(Runnable runnable) &#123; sDefaultExecutor.execute(runnable); &#125; 其实就是用默认实现的SerialExecutor线程池去执行任务，这里可以提交多个任务，上面我们也分析过SerialExecutor任务是串行执行的，这意味着，这个方法的多个任务也是串行执行的。 验证 先验证，多个实例对象的方法是串行执行的 12345678910111213141516171819202122232425262728293031323334353637383940public class AsyncTaskTest extends BaseActivity &#123; @BindView(R.id.progress_tv) TextView mProgressView; @BindView(R.id.content_tv) TextView mContentView; @Override protected int getContentViewResId() &#123; return R.layout.activity_async_task_test; &#125; @Override protected void init() &#123; super.init(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; new AsyncTaskImpl().execute(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static class AsyncTaskImpl extends AsyncTask&lt;Void, Void, Void&gt; &#123; @Override protected Void doInBackground(Void... voids) &#123; try &#123; Thread.sleep(2000); System.out.println(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; &#125; 打印如下： 12345678910I/System.out: 1526473028045I/System.out: 1526473030050I/System.out: 1526473032054I/System.out: 1526473034059I/System.out: 1526473036061I/System.out: 1526473038065I/System.out: 1526473040067I/System.out: 1526473042070I/System.out: 1526473044073I/System.out: 1526473046075 每次打印都间隔了2秒以上，符合我们任务串行执行的预期。 再验证一下，调用静态任务执行方法也是串行执行的 123456789101112131415161718192021222324252627282930 public class AsyncTaskTest extends BaseActivity &#123; @Override protected int getContentViewResId() &#123; return R.layout.activity_async_task_test; &#125; @Override protected void init() &#123; super.init(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12345678910I/System.out: 1526473373076I/System.out: 1526473375081I/System.out: 1526473377085I/System.out: 1526473379090I/System.out: 1526473381093I/System.out: 1526473383094I/System.out: 1526473385096I/System.out: 1526473387098I/System.out: 1526473389099I/System.out: 1526473391101 打印如上，无需多言。 总结 AsyncTask是Android官方提供的用于执行低耗时的工具类 AsyncTask实现多任务串行执行的模式 AsyncTask能将任务执行的各个状态在方法中体现出来 AsyncTask可以被取消，取消方式与FutureTask一致 AsyncTask可以指定任务执行的线程池 多个AsyncTask的实例对象，默认是串行执行的 调用静态方法执行多个Runnable也是串行的]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java生产者/消费者模型的一种实现]]></title>
    <url>%2FJava%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B20180512%2F</url>
    <content type="text"><![CDATA[本文主要介绍java中生产者/消费者模式的实现，对java线程锁机制的一次深入理解。生产者/消费者模型生产者/消费者模型要保证，同一个资源在同一时间节点下只能被最多一个线程访问，这个在java中用锁就很容易实现。下面的例子就是模拟多个生产者生产，多个消费者消费的demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//抽象生产者public abstract class AbstractProducer implements Runnable &#123; abstract void produce() throws InterruptedException; @Override public void run() &#123; try &#123; while (true) &#123; produce(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//抽象消费者public abstract class AbstractConsumer implements Runnable &#123; abstract void consume() throws InterruptedException; @Override public void run() &#123; try &#123; while (true) &#123; consume(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ConsumerAndProducerDemo &#123; private static final AtomicInteger ATOMIC_INTEGER = new AtomicInteger(); private static final ReentrantLock LOCK = new ReentrantLock(); private static final Condition CONDITION = LOCK.newCondition(); private static final Queue&lt;Product&gt; PRODUCTS = new LinkedList&lt;&gt;(); private static final int SIZE = 4; public static class Product &#123; int id; Product(int id) &#123; this.id = id; &#125; &#125; //实现消费者 private static class Consumer extends AbstractConsumer &#123; @Override void consume() throws InterruptedException &#123; try &#123; LOCK.lock(); while (PRODUCTS.isEmpty()) &#123; CONDITION.await(); &#125; Product product = PRODUCTS.poll(); Thread.sleep((long) (500 + Math.random() * 1000)); System.out.println(" consume product " + product.id); CONDITION.signalAll(); &#125; finally &#123; LOCK.unlock(); &#125; &#125; &#125; //实现生产者 private static class Producer extends AbstractProducer &#123; @Override void produce() throws InterruptedException &#123; try &#123; LOCK.lock(); while (PRODUCTS.size() &gt;= SIZE) &#123; CONDITION.await(); &#125; Thread.sleep(1000); Product product = new Product(ATOMIC_INTEGER.incrementAndGet()); PRODUCTS.add(product); System.out.println("produce product " + product.id); CONDITION.signalAll(); &#125; finally &#123; LOCK.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; for (int index = 0; index &lt; 2; index++) &#123; new Thread(new Producer()).start(); &#125; for (int index = 0; index &lt; 3; index++) &#123; new Thread(new Consumer()).start(); &#125; &#125;&#125; 上面的demo这么实现 启动多个线程模拟多个生产者和多个消费者 同时使用了queue用来缓存产品 当缓存区没满时生产者生产 当缓冲区满时消费者开始消费 线程之间的同步，这里使用了ReentrantLock，ReentrantLock在之前的博客中有介绍过，当然也可以使用Object自带的wait()等方法，实现同步这里就不在修改demo另行实现了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中Runnable、Callable、Future的介绍]]></title>
    <url>%2FJava%E4%B8%ADCallable%E3%80%81Future%E3%80%81FutureTask%E7%9A%84%E4%BB%8B%E7%BB%8D20180510%2F</url>
    <content type="text"><![CDATA[本文主要是为了介绍多线程中使用的几种任务：Runnable、Callable、FutureTask等，是对前面多线程系列的最后一个补充了，接下来两篇就是相当于实战练习了。Runnable 和 Callable的区别Runnable和Callable都是定义了接口，可以用在线程池中异步执行，区别是：Runnable可以直接被Thread执行，但是没有返回值Callable执行之后有返回值，但是只能提交给线程池执行。Future 和 FutureTaskFuture是一个接口，主要是线程池中任务执行之后用于返回结果的获取，定义了boolean cancel(boolean mayInterruptIfRunning); 取消任务boolean isCancelled(); 任务是否取消boolean isDone(); 任务是否执行完毕V get(); 获取任务执行的结果，注意这个方法阻塞线程V get(long timeout, TimeUnit unit)； 同上，只是增加了一个超时时间Future有一个直接继承接口RunnableFuture，RunnableFuture有一个实现的子类FutureTask，RunnableFuture这个接口同时还继承了Runnable接口，这意味着FutureTask可以作为Future或者Runnable使用。再来看一下FutureTask的实现，最终内部保存了一个Callable对象，也就是提交的任务先看构造函数12345678910111213141516171819202122232425public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; .../** * Creates a &#123;@code FutureTask&#125; that will, upon running, execute the * given &#123;@code Runnable&#125;, and arrange that &#123;@code get&#125; will return the * given result on successful completion. * * @param runnable the runnable task * @param result the result to return on successful completion. If * you don't need a particular result, consider using * constructions of the form: * &#123;@code Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)&#125; * @throws NullPointerException if the runnable is null */ public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; 一共2个构造函数，一个是接受Callable，一个是接受Runnable和默认返回值。 详细看一下第二个构造参数，注释很清楚的说明，当你需要runnable可取消同时不关心返回值时，可以这样构建 Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)； 同时构造函数里，Runnable被适配成了一个Callable，看一下里面的实现： 12345678910111213141516171819202122232425262728293031323334/** * Returns a &#123;@link Callable&#125; object that, when * called, runs the given task and returns the given result. This * can be useful when applying methods requiring a * &#123;@code Callable&#125; to an otherwise resultless action. * @param task the task to run * @param result the result to return * @param &lt;T&gt; the type of the result * @return a callable object * @throws NullPointerException if task null */ public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result); &#125; .../** * A callable that runs given task and returns given result */ static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125; &#125; 上面两个函数将一个Runnable适配成了一个Callable，是Executors中提供的静态方法。 再看一下FutureTask对Runnable的实现 1234567891011121314151617181920212223242526272829303132public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; 抛开其他的判断条件，其实就是对内部保存的Callable调用了call方法，进行执行并保存结果。这就是FutureTask主要的几个方法，下面有用。 ExecutorService中Future的应用上面2点主要是为了给这点做伏笔，现在我们来看为什么ExecutorService中的submit()既可以提交Runnable又可以提交Callable并返回结果，同时看看直接execute() Runnable会有什么不同。 Future submit(Runnable task)先来看一下这个方法的实现 123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask; &#125; 代码上可以很直观的看到，提交的Runnable被newTaskFor()适配成了RunnableFuture。来看一下newTaskFor()这个方法的实现。 123protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value); &#125; 直接是new了一个FutureTask对象，上面我们分析过这种情况，runnable其实是会被适配成一个Callable的。 Future submit(Callable task)再来看一下这个方法 123456public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; &#125; 跟上面的代码简直一摸一样，都是适配成了RunnableFuture。 看到这里可以明白，提交Runnable时是将Runnable适配成了Callable，也就是submit方法最终都会调用的的是Callable对象。 上面我们说过RunnableFuture实现了Runnable接口，当他被execute时，肯定是被当作Runnable使用的，看一下两个submit方法最终都是通过execute来执行的。 上面介绍FutureTask时我们知道，对Runnable的实现FutureTask最后调用的是Callable的call方法。 到这里可以知道了， 当我们提交一个Runnable的任务时，首先通过FutureTask的构造函数被适配成了一个Callable对象被保存FutureTask中。 当任务被执行时，FutureTask又被当作一个Runnable使用，调用了保存在内部的Callable的call方法，任务被执行并返回了结果。 Runnable被适配成Callable时最终调用的还是自己的run方法。 ExecutorService中execute()123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; 上面注释的意思是： 当前核心线程数少于corePoolSize是，尝试直接新建Thread用来执行任务。同时校验添加的过程，防止出错。 任务入队时二次校验是否需要新建线程，判断是否需要回滚等。 如果任务不能入队则新建非核心线程处理，如果失败那么就拒绝任务。 这个就是任务具体执行的过程，同时也可以知道为什么上一篇博客中通过反射获取workers的size就能知道当前线程的数量。 总结又到总结时间，博文主要讲了几个概念Runnable、Callable、Future以及相关的子类，总结如下： Runnable可以直接被Thread执行，但是没有返回值 Callable执行之后有返回值，但是只能提交给线程池执行。 Future定义了一系列关于任务取消的接口方法 FutureTask是Future唯一实现类，它也实现了Runnable接口 线程池submit Callable和Runnable时最终都会转换成FutureTask FutureTask被执行时是被当成Runnable使用的，执行了内部保存的Callable的call方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac美化之动态屏保、动态背景]]></title>
    <url>%2FMac%E7%BE%8E%E5%8C%96%E4%B9%8B%E5%8A%A8%E6%80%81%E9%94%81%E5%B1%8F%E3%80%81%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF20180509%2F</url>
    <content type="text"><![CDATA[本文主要介绍几个软件，用视频做屏保以及桌面壁纸动态壁纸动态壁纸目前用的是Backgrouds，App Store上目前的售价是¥3，当然也有破解版的。这是正版下载地址这是破解版下载地址性能也还过得去，监视器上看到，一般cpu使用率在7%，正常电脑cpu也就使用到20%左右的，不影响电脑其他的正常使用。使用上也比较简单，右键点击状态栏的图标后就可以即可看到设置的选项，勾选上视频即可，软件自带一个视频壁纸。要选择自己的视频也是可以的，还是上图，选择设置，然后进入设置页面后，选择红框内的 “ + ” 即可选择一个自己的喜欢的视频加入，如果要选择一整个文件夹下的视频，点击Add Folder选中要添加的目录即可。动态屏保这里介绍2种动态屏保，定期更换屏保图片以及视频做屏保定期更换屏保图片这里用的是Google’s Featured Photos Screensaver，有谷歌提供的使用Google+上的图片作为屏保图片，图片质量都挺不错这是官方下载链接，不过需要自备梯子。也可以通过这个百度云地址下载，密码是 gn4o下载下来的dmg文件直接双击安装即可， 安装好在桌面和屏保-&gt;屏保下找到Google’s Featured即可。动态视频屏保动态视频屏保用的SaveHollywood这是官方下载链接也可以用这个百度云地址，密码是 hmrk下载好后也是在桌面和屏保-&gt;屏保下选中SaveHollywood即可，点击Screen Saver Option按钮即可进行设置。点击上面➕，选择自己喜欢的视频做壁纸即可。视频壁纸上一个博主用的视频，来自网络知识保存了而已。下载地址，密码 bx11]]></content>
      <categories>
        <category>Mac OS X</category>
      </categories>
      <tags>
        <tag>Mac优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程简介]]></title>
    <url>%2FJava%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B20180507%2F</url>
    <content type="text"><![CDATA[主要是介绍一些线程相关的知识点，包括线程的生命周期，守护线程等，为后续的博客做一些铺垫。什么是线程关于什么是线程，网上一大堆的介绍:相对于进程，线程是操作系统(OS)调度的最小执行单元线程的特点，根据线程的官方介绍可以看出：java应用可以同时执行多个线程每个线程都有优先级，优先级高的线程优先于低优先级的线程执行线程在创建时可以设置为守护线程虚拟机启动时会有一个非守护线程的,也就是main方法所在的线程当一个应用程序所有的非守护线程死亡时，jvm退出，同时所有守护线程被销毁线程的创建有2种方式：继承Thread类并覆写run方法；在构造时传入一个Runnable实现类参数每个线程都有一个名字用于标识线程几个点需要说一下：当设置一个线程为守护线程时，只能在调用Start()方法前设置，否则抛出异常线程优先级分为1-10，默认为5死亡的线程无法再次被运行线程的生命周期线程的生命周期分为新建状态、就绪状态、运行状态、阻塞状态 和 死亡状态 5种状态，这5种状态的转换如下图所示：调用new关键字，新建一个Thread实例对象有，实例对象就处于新建状态。当Thread实例对象调用start()后，进入就绪状态可以被cpu调度执行。就绪状态的Thread实例对象，在获取到cpu执行权后就可以运行。同时由于cpu的切换或者调用了线程的yield方法，会导致运行状态的Thread回到就绪状态。当运行状态的线程遇到如下几种情况时将进入阻塞状态wait()sleep()join()等待同步锁阻塞式I/O调用阻塞状态的线程恢复进入就绪状态，当然在阻塞时线程被中断，那么线程进入死亡状态。运行状态的线程正常运行完毕或者中断异常都将进入死亡状态。守护线程相对于正常线程，也就是所谓的用户线程来说，守护线程主要是用于为用户线程提供便利，这也是守护这个词的含义，最典型的就是java系统的GC线程。当所有用户线程退出时，守护线程就没有服务对象也没有存在的意义，所以随着jvm的退出，所有的守护线程都会被销毁，这也就是java文档的说明。关于守护线程有如下几个注意点：设置守护线程必须在线程start()之前守护线程里执行的代码存在不完整执行的风险，所以涉及到数据计算保存的，需要有明确结果的操作不宜放在这里执行在守护线程下新建的线程也为守护线程关于第一点限制也很好理解，当你把启动的用户线程设置为守护线程时，可能刚好把唯一的用户线程消灭了，然后jvm退出了，导致了第二点的问题。举个例子验证一下上面说的，所有用户线程退出后jvm退出导致守护线程销毁的说法：123456789101112131415161718192021222324252627public class ThreadTest &#123; public static void main(String[] args) &#123; try &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; try &#123; int i = 0; while (true) &#123; System.out.println(i++); Thread.sleep(200); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; thread.setDaemon(true); thread.start(); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印结果如下： 123456701234Process finished with exit code 0 结果也很明显，每200毫秒打印一个数字，等主线程sleep结束就退出了。 如果把thread.setDaemon(true);注释调可以看到，线程一直会打印到底。 总结 线程有5种状态：新建状态、就绪状态、运行状态、阻塞状态 和 死亡状态 线程有2种创建方式 线程有优先级 线程有名字 守护线程需要在start()之前指定 守护线程代码可能执行不完整 守护线程下新建的多是守护线程]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A020180506%2F</url>
    <content type="text"><![CDATA[本文主要介绍java线程池相关的内容，包括线程池的几种常用方式线程池存在的意义先抛一个问题，Thread能直接新建并使用，为什么还要使用线程池?如果看过我之前写的博客的话可以知道，一个线程从新建到死亡，总共有5个状态。创建、运行包括死亡都会消耗cpu等系统资源。如果子线程每次执行的任务量很小，但是数量很大时，你会发现，基本上所有的系统资源都消耗在线程管理上。同时线程之间的执行权竞争也会消耗一定的系统资源，这就导致了程序的执行效率降低。另外还有一点就是，随意新建的线程无法做到统一管理。线程池的存在就是为了解决上面提到的问题，以提高程序的执行效率。ExecutorExecutor其实更准确的解释是执行器，定义了一个线程执行的规范，跟我们常说的线程池相差有点远。An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.这段话的意思是，Executor是用来执行被提交的Runnable任务的。这个接口提供了一种将任务提交与每个任务如何运行的机制解耦的方式，包括线程使用，调度等细节。通常Executor用来代替显示的创建线程。上面是官方给的注释，那Executor这跟我们今天要说的线程有什么关系呢。其实Executor是线程池的父类，最终的实现类有两个ThreadPoolExecutor以及ScheduledThreadPoolExecutor，其中ThreadPoolExecutor就是我们常说的线程池。在ThreadPoolExecutor之上还有一个接口ExecutorService，定义了任务提交、执行等一些相关接口，继承结构图如下所示：ExecutorService相对于Executor，ExecutorService更多是功能的定义，提供了诸如Futuresubmit(Callabletask);Future&lt;?&gt; submit(Runnable task);的方法，可以让线程执行返回结果。ThreadPoolExecutor这个才是我们常用的“线程池”，主要来看一下构造函数。ThreadPoolExecutor有4个构造函数，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125;...public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; ...public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125; ... public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 最后都是调用到了参数最长的那个，我们来看一下里面个各个参数的意思： corePoolSize ： 核心线程的数量 maximumPoolSize ： 最大线程数量，包括核心线程和非核心线程 keepAliveTime ： 非核心线程空闲时存活的时间 unit ： 存活时间的时间单位 workQueue ： 任务队列 threadFactory ： 创建线程的工厂类 handler ： 当任务无法被处理的对象 线程数量关于corePoolSize、maximumPoolSize和workQueue这里要单独拿出来讲一下。 首先要明确两个概念：核心线程和非核心线程。 核心线程是指线程空闲时也保存的线程池中的线程，最大数量就是corePoolSize个，当然如果设置了allowCoreThreadTimeOut，那么核心线程也会被回收。 非核心线程是指核心线程不够处理任务，同时线程池稍微到达maximumPoolSize时添加的线程，这些线程会在空闲keepAliveTime后被回收。 但是保存在线程池中的线程并没有真正的核心线程和非核心线程的区别，只是开始回收线程时，线程数量达到核心线程的数量便不再回收。 知道上面这个两个我们就可以接着往下讲了。 什么时候新建核心线程 当线程池的线程数量少于corePoolSize时，不管是否有核心线程空闲，只要来新任务，都是直接新建核心线程用来出来任务。 什么时候新建非核心线程 这个问题比较复杂一点，因为涉及到workQueue的类型以及容量问题，直接一点的的回答就是： 当workQueue被塞满时，这时来新的任务才会新建非核心线程进行处理，如果线程池中的线程数量达到了maximumPoolSize，这时再来新任务将被拒绝，同时抛出一个RejectedExecutionException。 但是存在一个特殊的情况，那就是设置的核心线程数量为0，这个时候会新建一个非核心线程用于处理任务 什么时候将任务放入workQueue 当线程池中的核心线程达到了corePoolSize，同时没有核心线程空闲，这时来新的任务都会被放入workQueue，当workQueue被塞满时就会尝试新建非核心线程。 所以我们可以看到，一个线程池中线程池中能存在的最大线程个数就是maximumPoolSize，但是能保存的最大任务数就会比这个大一点，是maximumPoolSize + workQueue.size() 之和。 大致的流程下图所示： 下面是demo验证一下正常情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ExecutorTest &#123; public static void main(String[] args) &#123;try &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(1, Integer.MAX_VALUE, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executor.execute(() -&gt; &#123; try &#123; Thread.sleep(200); System.out.println("runnable index is " + index + " and time is " + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; //workers 在线程池中用保存有新建完的线程，由于不存在直接获取的方法，这里用反射获取 Class clazz = executor.getClass(); Field workers = clazz.getDeclaredField("workers"); workers.setAccessible(true); while (true) &#123; HashSet hashSet = (HashSet) workers.get(executor); System.out.println("Queue size is " + executor.getQueue().size() + " and thread count is " + hashSet.size()); Thread.sleep(1000); &#125; &#125; catch (Exception ignore) &#123; &#125; &#125;&#125; 打印如下： 12345678910111213141516time is 1525846211057 and thread count is 1runnable index is 0 and time is 1525846211260runnable index is 1 and time is 1525846211464runnable index is 2 and time is 1525846211665runnable index is 3 and time is 1525846211870time is 1525846212062 and thread count is 1runnable index is 4 and time is 1525846212074time is 1525846213064 and thread count is 1time is 1525846214069 and thread count is 1time is 1525846215070 and thread count is 1time is 1525846216074 and thread count is 1time is 1525846217076 and thread count is 1time is 1525846218079 and thread count is 1time is 1525846219084 and thread count is 1time is 1525846220089 and thread count is 1time is 1525846221092 and thread count is 1 由于没有提供直接获取线程池中当前线程数量方法，用反射的方法来获取。 可以看到，就算非核心线程数量设置到了Integer.MAX_VALUE，但是任务队列并没有满，还是只有1个核心线程在执行任务。并且过了超时时间，线程并没有被销毁。 再来一个demo验证一下核心线程设置为0的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ExecutorTest &#123; public static void main(String[] args) &#123;try &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executor.execute(() -&gt; &#123; try &#123; Thread.sleep(200); System.out.println("runnable index is " + index + " and time is " + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; //workers 在线程池中用保存有新建完的线程，由于不存在直接获取的方法，这里用反射获取 Class clazz = executor.getClass(); Field workers = clazz.getDeclaredField("workers"); workers.setAccessible(true); while (true) &#123; HashSet hashSet = (HashSet) workers.get(executor); System.out.println("Queue size is " + executor.getQueue().size() + " and thread count is " + hashSet.size()); Thread.sleep(1000); &#125; &#125; catch (Exception ignore) &#123; &#125; &#125;&#125; 打印如下： 123456789101112131415time is 1525846316180 and thread count is 1runnable index is 0 and time is 1525846316383runnable index is 1 and time is 1525846316589runnable index is 2 and time is 1525846316793runnable index is 3 and time is 1525846316999time is 1525846317184 and thread count is 1runnable index is 4 and time is 1525846317201time is 1525846318188 and thread count is 1time is 1525846319193 and thread count is 1time is 1525846320197 and thread count is 1time is 1525846321198 and thread count is 1time is 1525846322202 and thread count is 1time is 1525846323206 and thread count is 0time is 1525846324206 and thread count is 0time is 1525846325211 and thread count is 0 当核心线程设置为0时，提交任务给线程池，会新建一个非核心线程用于处理任务，过了超时时间后线程就被回收了。 Executors提供的4种默认线程池Executors是一个线程池的工具类，最主要的用处就是给我们提供了4种常用的线程池的创建方式。 newFixedThreadPool(int nThreads)这个静态返回一个固定线程数量的线程池，来看一下里面的实现。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 这里就开始用到文章上面所解释的参数的意义，这里可以看到，核心线程和最大线程数量都为指定的nThreads，非核心线程超市时间为0，也就是默认值，任务队列为一个LinkedBlockingQueue。 解释一下为什么这是一个固定线程的线程池，结合上面的任务分配图可以很清楚的知道， 当新任务来时，最开始肯定是新建核心线程进行任务直接处理 当核心线程满了之后就是任务入队了，但是LinkedBlockingQueue理论上是一个无限大的队列，可以一直存放任务，这个线程池中不会存在非核心线程，线程的数量也就固定了。 newSingleThreadExecutor()这个就是新建一个只有一个核心线程的线程池。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 这个就不多解释了，看上面就知道了，只是把核心线程数指定为了1。 newCachedThreadPool()这就是不限制线程的数量，但是线程会被回收。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 还是套用上面的任务分配图： 核心线程数量为0，以为这所有的任务都先进任务队列 但是SynchronousQueue是一个同步的队列，也就是SynchronousQueue中不会存在任务，只要有新任务都是直接分配出去处理。 最大线程数量为Integer.MAX_VALUE，意味着可以处理的任务是无限量的。 看完上面几点可以知道，当有任务来时都是交给非核心线程处理的，线程数量不够时直接新建非核心线程。所有线程空闲超过60秒将会被回收，这也是Cached的含义。 newScheduledThreadPool(int corePoolSize)这个线程池主要用于执行需要重复执行的任务上，可以指定任务循环执行的模式。 1234public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; 可以看到最后其实是新建了一个ThreadPoolExecutor，设置的核心线程数为corePoolSize，队列为一个无限大小的延时队列。 三个方法说明一下： schedule(Runnable command,long delay,TimeUnit unit)：就是一个只执行一次的延时任务，这个方法接受3个参数 执行的任务 延时的时间 时间单位 scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)： 这是一个无限次执行的延时任务，这个方法接受4个参数 执行的任务 第一次开始执行的延时 以后每次开始的延时 时间单位 scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)：这是一个无限次执行的延时任务，只不过每次新任务总在上一个任务执行完毕开始，这方法接受4个参数 执行的任务 第一次开始执行的延时 上个任务结束后，开始下个任务的延时 时间单位 总结这篇基本上算都是干货了，总结没啥好写的，再看一遍文章，能记住的都记住吧，特别是文中提到的几个问题。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java同步实现方式]]></title>
    <url>%2FJava%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F20180504%2F</url>
    <content type="text"><![CDATA[本文主要是介绍java中线程同步的几种常用方式。CountDownLatch从字面上理解，CountDownLatch是一个同步等待的锁，根据官方的注释可以看出这其实是一个同步执行工具类。先看一下官方注释的前两段1234567891011/** * A synchronization aid that allows one or more threads to wait until * a set of operations being performed in other threads completes. * * &lt;p&gt;A &#123;@code CountDownLatch&#125; is initialized with a given &lt;em&gt;count&lt;/em&gt;. * The &#123;@link #await await&#125; methods block until the current count reaches * zero due to invocations of the &#123;@link #countDown&#125; method, after which * all waiting threads are released and any subsequent invocations of * &#123;@link #await await&#125; return immediately. This is a one-shot phenomenon * -- the count cannot be reset. If you need a version that resets the * count, consider using a &#123;@link CyclicBarrier&#125;. 翻译一下就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * CountDownLatch是一个，允许一个或多个线程， * 等待其他线程中执行的一组操作完成的，同步辅助工具。 * * CountDownLatch用给定的计数进行初始化。 * 当线程点用await方法后被阻塞，直到当前计数由于其他线程调用countDown()方法而达到零， * 此后所有等待线程被放，并且任何后续调用await立即返回。 * 这是一次性的操作，计数无法重置。 * 如果您需要重置计数的版本，请考虑使用CyclicBarrier。 * /``` 解释的很清楚，不在赘述，接着看一下官方提供的伪代码案例#### 官方案例一```javaclass Driver &#123; // ... void main() throws InterruptedException &#123; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); // don't let run yet startSignal.countDown(); // let all threads proceed doSomethingElse(); doneSignal.await(); // wait for all to finish &#125; &#125; class Worker implements Runnable &#123; private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; public void run() &#123; try &#123; startSignal.await(); doWork(); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; ... &#125; &#125; 这个案例很直白的说明了，CountDownLatch可以让多个线程同时初始化完成后等待，直到主线程要求他们开始执行为止，并且当主线程调用await()之后阻塞直到所有的线程调用countDown()将计数减为0，主线程再次唤醒执行后序操作。 当然这样还有一些其他的注意点，譬如子线程被中断或者子线程的耗时操作很长导致主线程一直阻塞等问题。 官方案例二1234567891011121314151617181920212223242526272829class Driver2 &#123; // ... void main() throws InterruptedException &#123; CountDownLatch doneSignal = new CountDownLatch(N); Executor e = ... for (int i = 0; i &lt; N; ++i) // create and start threads e.execute(new WorkerRunnable(doneSignal, i)); doneSignal.await(); // wait for all to finish &#125; &#125; class WorkerRunnable implements Runnable &#123; private final CountDownLatch doneSignal; private final int i; WorkerRunnable(CountDownLatch doneSignal, int i) &#123; this.doneSignal = doneSignal; this.i = i; &#125; public void run() &#123; try &#123; doWork(i); doneSignal.countDown(); &#125; catch (InterruptedException ex) &#123;&#125; // return; &#125; void doWork() &#123; ... &#125; &#125;&#125; 这个案例是说，当一个问题需要被分成n份进行处理时，将他们用线程池来执行，并让主线程等待。当然官方注释里还说了，如果需要反复用这种形式来执行一些问题时可以考虑使用CyclicBarrier来代替CountDownLatch，因为CountDownLatch是一次性的计数器无法重置。 CyclicBarrier字面意思：可循环使用的栅栏。主要的作用也是让指定个数的线程到达目标位置后进入等到状态，等所有的线程都到到目标位置后同时开始执行。 构造方法有2个 CyclicBarrier(int parties)，其中parties指等待的线程数目 CyclicBarrier(int parties, Runnable barrierAction)，第二个参数指所有线程达到后执行的操作。 通过第二个构造方法也可以实现CountDownLatch功能，当然这不是CyclicBarrier的目的 再来看一下到达目标位置时的等待方法，有2个重载方法 await()，这个没什么可说的，到达指定位置后等待 await(long timeout, TimeUnit unit)，这个指到到指定位置后等待一段时间，如果超时则继续执行后序操作。 现在来看2个例子说明一下使用CyclicBarrier可能出现的问题 CyclicBarrier例一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; try &#123; final int Num = 5; CyclicBarrier cyclicBarrier = new CyclicBarrier(Num); for (int i = 0; i &lt; Num - 1; i++) &#123; new Thread(new RunnableOne(cyclicBarrier)).start(); &#125; Thread thread = new Thread(new RunnableTwo(cyclicBarrier)); thread.start(); Thread.sleep(2000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static class RunnableOne implements Runnable &#123; CyclicBarrier mCyclicBarrier; RunnableOne(CyclicBarrier cyclicBarrier) &#123; mCyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; System.out.println("wait in barrier"); mCyclicBarrier.await(); System.out.println("finish"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class RunnableTwo implements Runnable &#123; CyclicBarrier mCyclicBarrier; RunnableTwo(CyclicBarrier cyclicBarrier) &#123; mCyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; System.out.println("wait in barrier"); Thread.sleep(5000); mCyclicBarrier.await(); System.out.println("finish"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印结果如下： 123456789wait in barrierwait in barrierwait in barrierwait in barrierwait in barrierjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.jxx.myjavatest.CyclicBarrierTest$RunnableTwo.run(CyclicBarrierTest.java:65) at java.lang.Thread.run(Thread.java:748) 这个例子的意图也很简单，启动4个RunnableOne，随后启动1个RunnableTwo，在所有线程都await()之前其中一个线程被中断了，因为没有都await()成功，其他4个线程就一直阻塞。这就提醒我们，要在抛出异常后及时处理，至少也要让其他线程能正常执行下去。 CyclicBarrier例二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; final int Num = 5; CyclicBarrier cyclicBarrier = new CyclicBarrier(Num); for (int i = 0; i &lt; Num - 1; i++) &#123; new Thread(new RunnableOne(cyclicBarrier)).start(); &#125; Thread thread = new Thread(new RunnableTwo(cyclicBarrier)); thread.start(); &#125; private static class RunnableOne implements Runnable &#123; CyclicBarrier mCyclicBarrier; RunnableOne(CyclicBarrier cyclicBarrier) &#123; mCyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; System.out.println("wait in barrier"); Thread.sleep(5000); mCyclicBarrier.await(); System.out.println("finish"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class RunnableTwo implements Runnable &#123; CyclicBarrier mCyclicBarrier; RunnableTwo(CyclicBarrier cyclicBarrier) &#123; mCyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; System.out.println("wait in barrier"); mCyclicBarrier.await(2000, TimeUnit.MILLISECONDS); System.out.println("finish"); &#125; catch (InterruptedException | BrokenBarrierException | TimeoutException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 打印如下： 123456789101112131415161718192021222324252627282930wait in barrierwait in barrierwait in barrierwait in barrierwait in barrierjava.util.concurrent.TimeoutException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435) at com.jxx.myjavatest.CyclicBarrierTest$RunnableTwo.run(CyclicBarrierTest.java:61) at java.lang.Thread.run(Thread.java:748)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.jxx.myjavatest.CyclicBarrierTest$RunnableOne.run(CyclicBarrierTest.java:40) at java.lang.Thread.run(Thread.java:748)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.jxx.myjavatest.CyclicBarrierTest$RunnableOne.run(CyclicBarrierTest.java:40) at java.lang.Thread.run(Thread.java:748)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.jxx.myjavatest.CyclicBarrierTest$RunnableOne.run(CyclicBarrierTest.java:40) at java.lang.Thread.run(Thread.java:748)java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207) at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362) at com.jxx.myjavatest.CyclicBarrierTest$RunnableOne.run(CyclicBarrierTest.java:40) at java.lang.Thread.run(Thread.java:748) 这里模拟了一个await()超时的异常，可以看到在抛出异常后需要我们自己处理后期的事物。同时某一个线程抛出超时异常后，其他线程再次到达会抛出BrokenBarrierException异常，防止继续等待。 Semaphore其实Semaphore不该放到这里讲，因为Semaphore类似于Lock的存在，是对资源或者线程的一种控制，但是这篇博文主要讲了线程的等待唤起，信号量放这里讲问题也不大。 官方的说法是信号量通常用来限制线程的数量，而不是控制访问一些（物理或逻辑）资源。用法也非常简单，使用前先acquire()获取许可，在获取许可过程中，是线程是被阻塞的，使用完毕release()许可即可。这点类似于Lock，不同的是Semaphore的acquire()可以被允许多次。 Semaphore有两个构造方法，可以指定Semaphore获取是公平的还是非公平的，默认是非公平 看这里，举个栗子： 1234567891011121314151617181920212223242526272829303132333435363738public class SemaphoreTest &#123; public static void main(String[] args) &#123; CountDownLatch startLatch = new CountDownLatch(1); Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new MyRunnable(startLatch, semaphore)).start(); &#125; startLatch.countDown(); &#125; private static class MyRunnable implements Runnable &#123; final CountDownLatch mCountDownLatch; final Semaphore mSemaphore; MyRunnable(CountDownLatch countDownLatch, Semaphore semaphore) &#123; mCountDownLatch = countDownLatch; mSemaphore = semaphore; &#125; @Override public void run() &#123; try &#123; mCountDownLatch.await(); mSemaphore.acquire(); System.out.println(Thread.currentThread().getName() + " acquire success"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mSemaphore.release(); &#125; &#125; &#125;&#125; 打印如下： 12345678910Thread-0 acquire successThread-1 acquire successThread-9 acquire successThread-3 acquire successThread-2 acquire successThread-4 acquire successThread-6 acquire successThread-7 acquire successThread-5 acquire successThread-8 acquire success 可以看出这是默认的非公平锁的情况，再来看一下公平锁的情况 1234567891011121314151617181920212223242526272829303132public class SemaphoreTest &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3, true); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new MyRunnable(semaphore)).start(); &#125; &#125; private static class MyRunnable implements Runnable &#123; final Semaphore mSemaphore; MyRunnable(Semaphore semaphore) &#123; mSemaphore = semaphore; &#125; @Override public void run() &#123; try &#123; mSemaphore.acquire(); System.out.println(Thread.currentThread().getName() + " acquire success"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mSemaphore.release(); &#125; &#125; &#125;&#125; 打印如下 12345678910Thread-0 acquire successThread-1 acquire successThread-2 acquire successThread-3 acquire successThread-4 acquire successThread-5 acquire successThread-6 acquire successThread-7 acquire successThread-8 acquire successThread-9 acquire success 当然这里肯定有读者想了，直接将Semaphore置为true公平锁的情况就好了，何必去掉CountDownLatch呢。 这里需要注意下，虽然你Semaphore是公平，但是CountDownLatch到点之后唤起线程的顺序是随机的，并不一定就是线程入队的顺序唤起。 线程的join()jion方法的作用是让主线程阻塞等待子线程完成，当然有几个前提条件，下面细说。 join方法有三个重载的版本 final void join(); //一直等待到join的线程执行完毕 final synchronized void join(long millis); //等待指定时间后继续执行 final synchronized void join(long millis, int nanos); 同上，时间处理了一下 第一个和第三个最后其实调用的都是第二个重载方法，我们来看一下源码 123456789101112131415161718192021222324public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 直接看最后的while循环，可以看到，调用这个方法，其实是调用Object提供的wait(long timeout)让主线程阻塞而已。有几个注意点 子线程如果已经销毁，则直接跳过等待 join(long millis) 是一个同步方位，意味着要想调用此方法需要先获取到子线程的实例对象锁 来看一个例子，验证一下第二点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class JoinTest &#123; public static void main(String[] args) &#123; final Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(6000); System.out.println("4---" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); try &#123; System.out.println("1---" + System.currentTimeMillis()); new Thread(new MyRunnable(thread)).start(); System.out.println("2---" + System.currentTimeMillis()); thread.join(2000); System.out.println("3---" + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("finish " + System.currentTimeMillis()); &#125; private static class MyRunnable implements Runnable &#123; final Object mObject; MyRunnable(Object object) &#123; mObject = object; &#125; @Override public void run() &#123; synchronized (mObject) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 打印如下： 123451---15255298034452---15255298034463---1525529807449finish 15255298074494---1525529809445 可以很清晰的看到，打印完1之后立即打印了2，但是2和3之间打相差了4秒，原因就在join之前需要先获取thread的锁对象，但是需要MyRunnable释放锁之后才能执行。 总结好了，又到总结的时间了。 CountDownLatch相对于CyclicBarrier侧重点是，等待其他线程操作完成后主线程在继续后续的操作 CyclicBarrier相对于CountDownLatch侧重点是，所有的线程操作完成后等待一起继续后续操作。 CountDownLatch不能重置状态，CyclicBarrier可以重置后多次利用 CountDownLatch和CyclicBarrier抛出异常后都需要妥善处理 Semaphore于Lock类似，主要用于线程的访问控制，构造时可以指定是否是公平竞争 thread.join()主要是让主线程等待子线程执行完毕，有个注意点就是join()执行之前需要获取到子线程的实例对象锁。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程中断]]></title>
    <url>%2FJava%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD20180503%2F</url>
    <content type="text"><![CDATA[本文主要介绍Java线程中断一些相关的概念以及注意点Java线程的中断并不是强制的中断，调用线程中断的方法时只是起到一个通知的作用，至于线程是否要继续执行下去取决于线程自身的处理。除去已经不推荐使用的thread.stop()方法，主要讲一下线程的成员方法thread.interrupt()、thread.isInterrupted()以及静态方法Thread.interrupted()interrupt()先看一下这个方法的介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Interrupts this thread. * * &lt;p&gt; Unless the current thread is interrupting itself, which is * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method * of this thread is invoked, which may cause a &#123;@link * SecurityException&#125; to be thrown. * * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125; * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;, * methods of this class, then its interrupt status will be cleared and it * will receive an &#123;@link InterruptedException&#125;. * * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125; * then the channel will be closed, the thread's interrupt * status will be set, and the thread will receive a &#123;@link * java.nio.channels.ClosedByInterruptException&#125;. * * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125; * then the thread's interrupt status will be set and it will return * immediately from the selection operation, possibly with a non-zero * value, just as if the selector's &#123;@link * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked. * * &lt;p&gt; If none of the previous conditions hold then this thread's interrupt * status will be set. &lt;/p&gt; * * &lt;p&gt; Interrupting a thread that is not alive need not have any effect. * * @throws SecurityException * if the current thread cannot modify this thread * * @revised 6.0 * @spec JSR-51 */ public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0(); &#125; 上面是官方关于interrupt()定义，大致的意思是： 线程中断自己是被允许的。除非当前线程正在中断，否则当前线程的checkAccess()会被调用，这可能会抛出SecurityException异常 当线程被Object中定义的 wait()、wait(long)或wait(long, int)以及线程中的jion()、join(long)、join(long, int)、sleep(long)或sleep(long, int)进入阻塞状态，调用interrupt()时线程的中断标记会被清除，同时抛出一个InterruptedException异常。 如果当前线程在可中断通道的I / O操作中被阻塞，则通道将被关闭，线程的中断状态将被设置为true，并且线程将收到ClosedByInterruptException。 如果当前线程在选择器中被阻塞，那么线程的中断状态将被设置为true，并且它将立即从选择操作中返回，可能具有非零值，就像调用选择器的唤醒方法一样。 如果上述情况都没有发生，那么线程的中断状态将被设置为true。 isInterrupted()、interrupted()1234567891011121314151617181920/** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #isInterrupted() * @revised 6.0 */ public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125; 上面注释主要是这个意思： 这个方法主要用于测试当前线程是否被中断，同时当前线程的中断状态会被清除。换句话说，连续调用两次这个方法，返回的结果肯定是false，当然有例外，就是第一次调用完这个方法且第二次尚未开始调用的时候，线程再次被中断，也就是中断状态再次被设置为true的情况。 当线程不存活时，线程的中断将被忽略，通过这个方法返回false来反映。 注意点是，这是Thread的静态方法 12345678910111213141516/** * Tests whether this thread has been interrupted. The &lt;i&gt;interrupted * status&lt;/i&gt; of the thread is unaffected by this method. * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #interrupted() * @revised 6.0 */ public boolean isInterrupted() &#123; return isInterrupted(false); &#125; 这个方法和上面的静态方法的主要区别是，这个成员方法调用后并不清除中断状态 线程中断从上面的3个方法的注释可以看出，线程的中断并不是强制中断，除了可以能抛出异常的情况，都需要自己去处理。对于抛出异常情况，如果自己不想处理，最好是将异常往上传递，可以给其他用户一个处理异常的机会。如果对interrupt不处理又不反馈任何信息，就会像下面这样。 典型的synchronized对线程的中断并不处理 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadInterruptTest &#123; public static void main(String[] args) &#123; try &#123; Object object = new Object(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; synchronized (object) &#123; Thread.sleep(5000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); Thread.sleep(2000); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (object)&#123; System.out.println("get lock"); &#125; &#125; &#125;); thread.start(); Thread.sleep(1000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5秒之后打印： 1get lock 因为synchronized不处理，线程阻塞在获取锁的状态根本中断不了。 对于想中断的线程，我们可以这样操作： 1234567891011121314151617181920212223242526272829public class ThreadInterruptTest &#123; public static void main(String[] args) &#123; try &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; while (true) &#123; Thread.sleep(1000); System.out.println("in while loop"); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("InterruptedException"); &#125; &#125; &#125;); thread.start(); Thread.sleep(4000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印如下： 1234in while loopin while loopin while loopInterruptedException 正常中断了线程 再来看一种特殊情况： 1234567891011121314151617181920212223242526272829public class ThreadInterruptTest &#123; public static void main(String[] args) &#123; try &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); System.out.println("in while loop"); &#125; catch (InterruptedException e) &#123; System.out.println("InterruptedException"); &#125; &#125; &#125; &#125;); thread.start(); Thread.sleep(4000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印是这样的： 123456789in while loopin while loopin while loopInterruptedExceptionin while loopin while loopin while loopin while loop... 程序进入了死循环，猜到什么原因了吗？上面关于thread.interrupt()的注释里面明确说明了，当抛出InterruptedException异常时，线程的中断标记会被清除！！！这就是引起死循环的原因。我们可以这样处理，在捕捉到异常后后加上Thread.currentThread().isInterrupted();再次设置中断的标记。或者像最开始的写法，将整个while循环放try里面。 当然也可以通过自己维护flag的形式来中断线程 12345678910111213141516171819202122232425262728293031323334public class ThreadInterruptTest &#123; private static volatile boolean interruptFlag = false; public static void main(String[] args) &#123; try &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!interruptFlag) &#123; System.out.println("in while loop"); &#125; System.out.println("interrupted"); &#125; &#125;) &#123; @Override public void interrupt() &#123; super.interrupt(); interruptFlag = true; &#125; &#125;; thread.start(); Thread.sleep(2000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后看一下调用interrupted(),清除中断标记的情况 123456789101112131415public class ThreadInterruptTest &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.interrupted()); System.out.println(Thread.interrupted()); &#125; &#125;); thread.start(); thread.interrupt(); &#125;&#125; 打印如下： 12truefalse 总结 线程调用interrupt()之后并一定会中断，例如在等待synchronized锁的状态下 线程在sleep()、wait()、jion()等阻塞状态下被中断会抛出InterruptedException异常，同时中断标记被清除 连续调用两次静态方法interrupted()第二次将返回false（特殊情况注意一下）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java锁机制]]></title>
    <url>%2FJava%E9%94%81%E6%9C%BA%E5%88%B620180502%2F</url>
    <content type="text"><![CDATA[Java多线程编程的入门篇，主要介绍Synchronized、Lock及其子类以及volatile修饰词多线程编程主要存在的问题是数据的同步问题，下面我们讲讲几种保证数据同步的方法volatile要想了解volatile修饰词就必须先说说并发编程中的3个概念：原子性原子性指的是：多个操作要么全部执行不可中断，要么全部不执行。 可见性可见性指的是：多线程操作同一个数据时， 其中一个线程操作完数据其他线程能立即看到数据的改变 （java中通过volatile来保证）。 有序性有序性指的是：程序执行过程按照代码的顺序执行， 虽然编译器和处理器可能会对指令进行重排序， 但是保证执行的结果相同。 再来了解一下java的内存模型，就可以知道java怎么通过volatile来保证数据的可见性java的内存模型Java内存模型中规定，所有的数据都存储在主内存中， 线程对要操作的数据从主线程拷贝到自己的工作内存。 每个线程只能操作自己工作内存中的数据，不能直接操作主内存中的数据， 也不能访问其他线程的工作内存。 同时线程操作的数据可能存在缓存中，并不直接刷新到主内存中， 从上面可以知道，如果不保证数据的可见性，多个线程一起操作同一份数据时，并不能保证线程从主线程拷贝下来的数据是最新的，这样会让计算结果产生偏差。这个时候volatile就起作用了，被volatile修饰的变量，在被线程操作时数据的改变能直接刷新到主内存中，保证这个操作产生的新数据对其他线程是可见的，其他线程从主内存读取到是最新的数据。同时volatile还有另外一个作用，被volatile修饰的变量将不能被编译器和处理器指令重排序。也就是volatile之后的语句不能提前到volatile之前，同时volatile之前的语句也不能排列到volatile之后。示例：1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 参考文献Java并发编程：volatile关键字解析 SynchronizedSynchronized同步锁比较好理解，可以作用于代码块、成员方法以及静态方。但是要求锁住的部分，持有的是同一个锁对象，这时才能Synchronized起作用。 作用于代码块某些情况下，我们可能在方法的一部分出现耗时操作，为了避免锁住整个方法可以用Synchronized同步代码块 12345678910111213141516171819202122232425262728293031323334353637383940public class SynchronizedTest &#123; public static int sInt = 0; public static void main(String[] args) &#123; new Thread(new MyRunnable(SynchronizedTest.class, false)).start(); new Thread(new MyRunnable(SynchronizedTest.class, true)).start(); &#125; private static class MyRunnable implements Runnable &#123; private final Object lock; boolean flag; public MyRunnable(Object lock, boolean flag) &#123; this.lock = lock; this.flag = flag; &#125; @Override public void run() &#123; if (flag) &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 1000; i++) &#123; sInt++; &#125; System.out.println("calc finish"); &#125; &#125; else &#123; System.out.println("hello world"); &#125; &#125; &#125;&#125; 打印如下： 12hello world 1525252712746calc finish 1525252712747 可以看出同步访问 作用于成员方法这个很好理解，我们需要锁住一整个方法，直接在方法上添加Synchronized即可 1234567891011121314151617181920212223242526272829303132public class SynchronizedTest &#123; public static int sInt = 0; public static void main(String[] args) &#123; SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.Test(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.Test(); &#125; &#125;).start(); &#125; private synchronized void Test() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println("Test finish at " + System.currentTimeMillis()); &#125; &#125;&#125; 打印如下： 12Test finish at 1525253058767Test finish at 1525253060770 可以看出两者的打印查了2秒以上。 这里需要特别说明一下，当Synchronized作用在成员方法上时其实是有锁对象的，持有的对象为当前的实例对象，这个和作用在静态方法上时有所区别，这个等下说。先看一下，不同实例时，成员方法上的锁是否生效。 123456789101112131415161718192021222324252627282930313233public class SynchronizedTest &#123; public static int sInt = 0; public static void main(String[] args) &#123; SynchronizedTest testOne = new SynchronizedTest(); SynchronizedTest testTwo = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; testOne.Test(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; testTwo.Test(); &#125; &#125;).start(); &#125; private synchronized void Test() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println("Test finish at " + System.currentTimeMillis()); &#125; &#125;&#125; 打印如下： 12Test finish at 1525253495010Test finish at 1525253495010 同时执行完毕，不同对象时锁依然存在，只是持有的锁对象不是同一个，所以才会同步打印。 作用于静态方法123456789101112131415161718192021222324252627282930313233public class SynchronizedTest &#123; public static int sInt = 0; public static void main(String[] args) &#123; SynchronizedTest testOne = new SynchronizedTest(); SynchronizedTest testTwo = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; testOne.Test(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; testTwo.Test(); &#125; &#125;).start(); &#125; public synchronized static void Test() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println("Test finish at " + System.currentTimeMillis()); &#125; &#125;&#125; 打印如下： 12Test finish at 1525253718091Test finish at 1525253720095 这里和synchronized作用于成员方法时有区别，当synchronized作用于静态方法时，持有的锁对象为当前类的.class对象，所有不同的实例来操作都是同步的，因为.class对象时唯一的。 synchronized可重入性先看一个示例 1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedTest &#123; private final Object mLock = new Object(); public static void main(String[] args) &#123; new SynchronizedTest().TestOne(); System.out.println(); new SynchronizedTest().TestFour(); &#125; private synchronized void TestOne() &#123; System.out.println("Test One"); TestTwo(); &#125; private synchronized void TestTwo() &#123; System.out.println("Test Two"); TestThree(); &#125; private synchronized void TestThree() &#123; System.out.println("Test Three"); &#125; private void TestFour() &#123; synchronized (mLock) &#123; System.out.println("Test Four"); TestFive(); &#125; &#125; private void TestFive() &#123; synchronized (mLock) &#123; System.out.println("Test Five"); &#125; &#125;&#125; 打印如下： 123456Test OneTest TwoTest ThreeTest FourTest Five 可以看出，程序并没有产生死锁，正常输入，这就是synchronized可重入性 在讲Lock前，先讲几个Object的方法 wait()、notify()以及notifyAll()这几个方法时Object中的方法，所有每个锁对象都能调用 wait()只有在同步代码块或者同步方法中才能调用，因为要保证当前线程持有锁对象。wait()的作用是让当前执行代码的线程进入等待状态，直到为唤起或者中断。 notify()作用是将等待状态的线程唤起，让它等待获取锁对象。不同于notifyAll(),如果有多个线程需要唤起，notify()会随机挑选一个线程进行唤起，其他线程继续等待。notify()也需要获取到锁对象，同时被唤起的线程也不能立即被执行，因为需要等待notify()的线程执行完毕并释放锁。 notifyAll()唤醒所有的等待线程，等到notifyAll()释放锁后同步执行 看一个notify的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class SynchronizedTest &#123; public static void main(String[] args) &#123; try &#123; new Thread(new RunnableOne(Object.class)).start(); Thread.sleep(1000); new Thread(new RunnableTwo(Object.class)).start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static class RunnableOne implements Runnable &#123; private final Object mLock; RunnableOne(Object lock) &#123; mLock = lock; &#125; @Override public void run() &#123; synchronized (mLock) &#123; try &#123; System.out.println("wait start " + System.currentTimeMillis()); mLock.wait(); System.out.println("wait finish " + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private static class RunnableTwo implements Runnable &#123; private final Object mLock; RunnableTwo(Object lock) &#123; mLock = lock; &#125; @Override public void run() &#123; synchronized (mLock) &#123; try &#123; Thread.sleep(2000); mLock.notify(); System.out.println("notify thread " + System.currentTimeMillis()); Thread.sleep(2000); System.out.println("notify finish " + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 打印如下： 1234wait start 1525261601930notify thread 1525261604937notify finish 1525261606940wait finish 1525261606941 可以清楚的看到notify结束后wait才执行，符合我们的预期 再来看一个notifyAll的示例，将上面的代码启动多个RunnableOne，notify()改成notifyAll(） 打印如下： 123456789101112wait start 1525261838049wait start 1525261838049wait start 1525261838050wait start 1525261838050wait start 1525261838050notify thread 1525261841060notify finish 1525261843065wait finish 1525261843065wait finish 1525261843065wait finish 1525261843065wait finish 1525261843065wait finish 1525261843066 死锁死锁指的是某一线程一直持有锁对象不释放，其他线程无法获取锁对象的过程。产生死锁一般的原因都是多个锁对象一起使用，同时相互请求锁对象导致的。 看个示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SynchronizedTest &#123; public static final Object LOCK_ONE = new Object(); public static final Object LOCK_TWO = new Object(); public static void main(String[] args) &#123; try &#123; new Thread(new RunnableOne()).start(); Thread.sleep(1000); new Thread(new RunnableTwo()).start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static class RunnableOne implements Runnable &#123; @Override public void run() &#123; try &#123; synchronized (LOCK_ONE) &#123; Thread.sleep(2000); synchronized (LOCK_TWO) &#123; System.out.println(System.currentTimeMillis() + ""); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class RunnableTwo implements Runnable &#123; @Override public void run() &#123; try &#123; synchronized (LOCK_TWO) &#123; Thread.sleep(2000); synchronized (LOCK_ONE) &#123; System.out.println(System.currentTimeMillis() + ""); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 直接死锁无打印，因为这里第一个线程启动的时候获取到了LOCK_ONE，接着睡眠，线程二启动，获取到了LOCK_TWO，睡眠。当第一个线程再次起来去获取LOCK_TWO时，等待LOCK_TWO被释放；当第二个线程再次起来去获取LOCK_ONE时，等待LOCK_ONE释放，相互等待对方释放锁，也即进入死锁状态。 LockLock只是定义的一个接口，直接实现类是ReentrantLock，相对于synchronized锁，Lock可以在需要的情况下自我中断。下面来看一下ReentrantLock使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class LockTest &#123; public static void main(String[] args) &#123; try &#123; ReentrantLock reentrantLock = new ReentrantLock(); new Thread(new RunnableOne(reentrantLock)).start(); Thread.sleep(1000); new Thread(new RunnableTwo(reentrantLock)).start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static class RunnableOne implements Runnable &#123; final ReentrantLock mLock; public RunnableOne(ReentrantLock lock) &#123; mLock = lock; &#125; @Override public void run() &#123; try &#123; mLock.lock(); System.out.println("RunnableOne get lock " + System.currentTimeMillis()); Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mLock.unlock(); &#125; &#125; &#125; private static class RunnableTwo implements Runnable &#123; final ReentrantLock mLock; public RunnableTwo(ReentrantLock lock) &#123; mLock = lock; &#125; @Override public void run() &#123; try &#123; mLock.lock(); System.out.println("RunnableTwo get lock " + System.currentTimeMillis()); &#125; finally &#123; mLock.unlock(); &#125; &#125; &#125;&#125; 打印如下： 12RunnableOne get lock 1525316728346RunnableTwo get lock 1525316733350 线程2一直阻塞，等到线程1释放锁后才进行了打印，这和synchronized没区别 公平锁与非公平锁当然ReentrantLock还有其他的特性，比如可以在实例化时指定是否为公平锁。公平锁和非公平锁的区别就是，公平锁所有线程按入队的顺序排队获取锁，非公平锁就是抢占机制，先入队并不一定获取到锁。 1234567891011121314151617181920212223242526272829303132333435public class LockTest &#123; public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(false); Thread[] threads = new Thread[5]; for (int i = 0; i &lt; 5; i++) &#123; threads[i] = new Thread(new RunnableOne(reentrantLock)); &#125; for (Thread thread : threads) &#123; thread.start(); &#125; &#125; private static class RunnableOne implements Runnable &#123; final ReentrantLock mLock; RunnableOne(ReentrantLock lock) &#123; mLock = lock; &#125; @Override public void run() &#123; try &#123; mLock.lock(); System.out.println(Thread.currentThread().getName() + " get lock "); &#125; finally &#123; mLock.unlock(); &#125; &#125; &#125;&#125; 非公平锁的情况下，打印如下： 12345Thread-0 get lock Thread-4 get lock Thread-1 get lock Thread-2 get lock Thread-3 get lock 提前启动的线程并没有先得到锁 再来看一下公平锁，只需要将ReentrantLock实例化时fair参数传入true即可，看一下打印： 12345Thread-0 get lock Thread-1 get lock Thread-2 get lock Thread-3 get lock Thread-4 get lock 符合先启动的线程先获取锁的预期。 Lock中断相对于synchronized对线程中断的不处理，Lock还有一个方法lockInterruptibly(),可以让用户在必要的情况下自行中断对锁的请求，然后继续后续的操作。java的中断机制后续再写 来看一个例子 123456789101112131415161718192021222324252627282930313233343536public class LockTest &#123; public static void main(String[] args) &#123; try &#123; ReentrantLock reentrantLock = new ReentrantLock(); new Thread(new Runnable() &#123; @Override public void run() &#123; reentrantLock.lock(); &#125; &#125;).start(); Thread.sleep(1000); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; reentrantLock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; System.out.println("我被中断了"); &#125; &#125; &#125;); thread.start(); Thread.sleep(1000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印如下： 1我被中断了 很明显的一个区别，当使用synchronized时，并不需要你去捕捉异常，因为线程会一直阻塞在等待锁的位置，就算你主动去thread.interrupt() synchronized并不会做任何处理。 lock.lockInterruptibly()使用时就需要你主动将此处的代码try/catch，因为在线程中断后，这里会捕捉异常并抛给你处理。这也给了你更灵活处理事物的能力。 Conditionsynchronized中可以用锁对象的wait()、notify()以及notifyAll()实现等待，当然Lock也可以实现，不过子类实现相对应的Condition。 相对应的Condition里面的3个方法是await()、signal()、signalAll()。与wait()调用一样，await()之前也需要获取到锁对象，也就是Lock先要lock(),直接看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LockTest &#123; public static void main(String[] args) &#123; try &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; reentrantLock.lock(); System.out.println("wait start"); condition.await(); System.out.println("wait finish"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; reentrantLock.unlock(); &#125; &#125; &#125;).start(); Thread.sleep(1000); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; reentrantLock.lock(); System.out.println("signal start"); condition.signal(); System.out.println("signal finish"); &#125; finally &#123; reentrantLock.unlock(); &#125; &#125; &#125;); thread.start(); Thread.sleep(1000); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印如下： 1234wait startsignal startsignal finishwait finish ReentrantLock的其他诸如isLocked()等方法这里就不再花篇幅说明，有兴趣的同学可以自己查看源码 总结总结一下这篇文章的知识点： volatile修饰词：保证了操作的可见性，保证多线程操作时，数据从主内存拷贝的都是最新的 Synchronized修饰词：可作用于代码块、成员方法已经静态方法上，配合锁对象的wait()、nofity()以及nofityAll()可以实现等待/通知模型。 作用在代码块上时需要指定锁对象 作用于成员方法上时锁对象为当前实例对象也就是xxx.this 作用与静态方法上时锁对象为当前类的class对象也就是xxx.class wait()、nofity()以及nofityAll()调用前需要获得锁对象。 Lock：与Synchronized相比较用法就是需要用户手动上锁以及释放锁对象，同时多了一个lockInterruptibly()可以让用户手动中断等待线程，并捕获异常进行后续处理。配合Condition可以实现与Synchronized一样的等待/通知模型. 死锁：死锁指的是某一线程一直持有锁对象不释放，其他线程无法获取锁对象的过程。产生死锁一般的原因都是多个锁对象一起使用，同时相互请求锁对象导致的。 以上是个人能想到的关于锁的内容，并不保证写的完全对，如有问题可以留言给我，共同学习。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程系列]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%9720180502%2F</url>
    <content type="text"><![CDATA[多线程在编程过程中一个无法躲避的问题，涉及到的知识点也比较广泛，接下来会写一个系列解释多线程编程中需要了解一些知识点，本人才学浅薄只能讲解一下个人了解的内容，如有不全面之处大家可以在此提出异议。主要会从如下几个方面入手：Java线程简介Java锁机制（volatile、Synchronized、Lock）线程中断（interrupt()、interrupted()、isInterrupted()）同步工具类（CountDownLatch、CyclicBarrier、Semaphore、thread.join()）线程池（Executor）以及多种常用线程池的介绍Callable、Future、FutureTask的介绍多线程实例之生产者/消费者模型Android-AsyncTask讲解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac优化之右键菜单优化]]></title>
    <url>%2FMac%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8F%B3%E9%94%AE%E3%80%81Finder%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%9620180427%2F</url>
    <content type="text"><![CDATA[今天这篇文章主要为了解决Mac下右键不能新建文件的痛处，顺带添加文件复制剪切等功能主要用到两个软件：NewFileMenu以及TotalFinderNewFileMenuMac下右键不能新建文件一直饱受诟病，确实也没有Win下那般方便NewFileMenu可以解决这个痛处，让Mac右键菜单才能也能有新建文件的选项，当然也不单单是新建文件这么一个选项，多种格式可选。软件可以在Mac下App Store搜索到，也可以点这里跳转来看一下作者的介绍：可以在桌面以及文件夹上新建各种格式的文件，包括.txt .doc等格式的文件右键上显示的子菜单个数可以在设置中自定义，设置如下除了模版上给出的格式，同时也支持自定义新建文件的格式，具体操作如下：进入设置页面后，选择模版（Templates）点击下方的+按钮，选择你要文件格式（这里需要有一个之前新建过的，最好是空白的目标文件）添加成功后双击新建的条目可以修改Title、Prefix、Suffix等信息因为markdown格式用的比较多，所以自己添加markdown格式，有需求的同学可以自己尝试。TotalFinder相对于NewFileMenu，TotalFinder安装比较麻烦，个人主要为了如下几个个需求而安装：多个Finder后可以像Chrome的Tap一样在同一个窗口中展示。右键菜单可以直接copy file path。右键菜单显示复制、剪切文件。先上效果图：软件下载地址在这里安装过程需要重启电脑4次双击安装TotalFinder重启电脑，期间同时按住command+r进入系统恢复页面在终端输入1csrutil disable 关闭系统完整系保护 正常重启电脑，继续安装TotalFinder 安装完成后再次重启电脑，期间同时按住command+r进入系统恢复页面 在终端输入 1csrutil enable 恢复系统完整系保护 安装完成，开机即可 好了，本次Mac右键优化就到这里结束， 有兴趣的同学可以自行尝试。]]></content>
      <categories>
        <category>Mac OS X</category>
      </categories>
      <tags>
        <tag>Mac优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac优化之自定义全局快捷键]]></title>
    <url>%2FMac%E4%BC%98%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%BF%AB%E6%8D%B7%E9%94%AE20180426%2F</url>
    <content type="text"><![CDATA[相信很多从Win转Mac OS的同学都曾想过如果mac打开文件能像win下方便就好了，下面我们来看打开finder的2种快捷方式。系统自带的快捷键进入系统设置(System Preferences)选择键盘(Keyboard)选择快捷键(Shotcuts)选择焦点（Spotlight）勾选右侧的现实访达焦点窗口(Show Finder search window)如上可以打开自动自带的打开finder的快捷方式，试一下效果自定义全局快捷键接下来一下通过新建Service的方式自定义全局快捷键，这里并不局限于打开finder进入二级菜单页面打开其他选择Automator新建Service左侧菜单栏选择Utilities,同时选中Launch Application上方”Service Receives Selected”（服务接收选择），选择“no input”(任何应用程序)下方app选择，点击后拉到最下方，选择New Variable(新建)Path(路径)选择Other(其他)搜索Finder，并选中Finder.appcommand+s保存，保存自己的Service名(下一步有用)打开键盘的快捷键找到Services(服务)，选择刚刚新建的Service，并添加快捷键，完工！试一下效果：]]></content>
      <categories>
        <category>Mac OS X</category>
      </categories>
      <tags>
        <tag>Mac优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Looper、Handler、Message以及MessageQueue之间的关系]]></title>
    <url>%2FLooper%E3%80%81Handler%E3%80%81Message%E4%BB%A5%E5%8F%8AMessageQueue%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB20180424%2F</url>
    <content type="text"><![CDATA[本文主要讲解Android线程间通信的一种方式，即Handler机制。子线程使用Handler相信很多童鞋有过子线程中new Handler时系统报错的经历123java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()at android.os.Handler.&lt;init&gt;(Handler.java:203)at android.os.Handler.&lt;init&gt;(Handler.java:117) 报错的原因是，在没有调用过Looper.prepare()的子线程中不能new Handler。 正确的使用方式是 123456789new Thread() &#123; @Override public void run() &#123; Looper.prepare(); Looper looper = Looper.myLooper(); Looper.loop(); Handler handler = new Hander(); &#125; &#125;.start(); 这到底是什么原因，Handler的构造函数做了什么操作，Looper.prepare()做了什么处理，我们接着往下看。 Handler12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 这里可以很清晰的看到抛出的异常 12345mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; 接着看Looper中的实现。 Looper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final class Looper &#123; ... // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; ... /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; ... /** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked(); &#125; &#125;&#125; 上面贴了Looper的一些主要代码，主要工作流程如下： prepare() 中就做了一件事，用ThreadLoacl在当前Thread中保存了一份Looper实例对象，并保证了每个线程只拥有一个Looper实例对象，保证循环中的消息队列的唯一性。有兴趣的童鞋可以看看这个ThreadLocal类详解。 myLooper() 就是将当前线程中保存的Looper对象返回。 loop() 开启MessageQueue中消息列表的循环处理，若当前无消息则阻塞，有消息则发送。 Looper和Handler的联系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class Handler &#123; ... public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis); &#125; public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis); &#125; public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis); &#125; public final boolean postAtFrontOfQueue(Runnable r)&#123; return sendMessageAtFrontOfQueue(getPostMessage(r)); &#125; public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis)&#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; //消息入队 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; ...&#125; 上面这些方法，到最后调用就是个方法 12345678//消息入队 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 在开头的Hanlder构造函数里我们可以知道，这里所用的queue就是Looper中的queue，也就是Handler中发送的消息其实入到了Looper中，两者在这里关联起来。 这也就解释了为什么Handler实例化之前需要Looper先行prepare。 这里先说明一点，post(Runnable r)等一系列方法中，最后Runnable回调都会被设置到msg中的callback中，看下面这个2方法 123456789101112private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m; &#125; 这里特做说明，下文会用到这点。 Hanlder和Message的联系上面看到handler消息入队列的时候会给msg.target赋值为this，也就是当前handler实例对象。 在Looper的loop()中message从MessageQueue取出，并调用 msg.target.dispatchMessage(msg)，并传递给他的target进行处理，也就是哪个handler发送的消息，最后又经由谁来处理。 来看一下Handler的dispatchMessage() 1234567891011121314151617181920212223242526/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; /** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; //用户自行实现的消息处理 &#125; 上面可以清晰的看到 如果msg有回调，则msg的回掉先行处理msg； 如果Handler实例化时有传入Callback，则这个Callback处理msg； 最后由用户自行实现的消息处理方式处理msg。 从上面可以看出，如果msg没有回调，则都会回到Handler所在线程进行处理。这也就是可以利用Handler更新UI的原理。 好了，Hanlder机制的整体流程如下图所示(图片来源网络，侵删)： 文章看完了，肯定有童鞋有疑问，为什么在UI线程new Handler时不需要先进行Looper.perpare()，原因是系统自动帮你完成了UI线程Looper.perpare()操作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal类详解]]></title>
    <url>%2FThreadLocal%E7%B1%BB%E8%AF%A6%E8%A7%A320180423%2F</url>
    <content type="text"><![CDATA[Android中Handler中有使用到ThreadLocal相关的知识，本文对ThreadLocal源码做一次解读ThreadLocal的特性ThreadLocal是线程本地保存数据的变量，这也是“ThreadLocal”的字面意思。同一个ThreadLocal对象，在不同线程中可以保存不同的数据，每个线程都有自己独一份的ThreadLocalMap来保存数据，ThreadLocal对象只不过起到key的作用一个线程中可以有多个ThreadLocal对象，但是同一个ThreadLocal只能保存一份值，多次保存会替换之前保存的值理论上数据有所在线程独享，但是如果存入的数据被多线程访问，那还是会有并发访问的问题。所以ThreadLocalMap保存的数据并不建议保存共享数据。线程销毁后自动释放线程保存的数据。线程本地保存数据，提高数据访问的速度。ThreadLocal内部实现变量12//相当于ThreadLocal的hash，保存数据到ThreadLocalMap时用于确定存储的位置private final int threadLocalHashCode = nextHashCode(); 12//自增长的int值，静态变量，保证不重复private static AtomicInteger nextHashCode = new AtomicInteger(); 1234567//每次threadLocalHashCode增长都要加上这个值，注释写的，为了让哈希码能均匀的分布在2的N次方的数组里/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647; 123456/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 方法 1234//提供默认值，子类继承时可以复写protected T initialValue() &#123; return null;&#125; 1234567891011//返回保存在当前线程ThreadLocalMap中的T值，若map为null则返回默认值public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 123456789//保存T到当前线程的ThreadLocalMap中public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 1234567//清除保存的数据//因为数据本来就是保存在线程中，清除数据也不是必须操作， 但可以加快内存回收public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 上面是ThreadLocal内部基本的几个方法，我们接着来看ThreadLocal怎么好Thread联系起来。 set()方法会调用到createMap(),看一下源码 12345678910111213/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map * @param map the map to store. */ //这里可以很清除的看到，其实是new了ThreadLocalMap，并保存到了Thread中 //查看Thread的源码也可以看到，内部保存了一个ThreadLocalMap变量 void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 内部类 ThreadLocal内部定义了ThreadLocalMap类，并不是一个map类，内部使用WeakReference来操作数据，保存、获取等数据操作的实现都在这里。 123456789101112131415161718192021222324252627282930313233static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125; &#125; ... /** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */ private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; &#125; 看过HashMap源码实现的同学看到这里肯定不会陌生，这就相当于是HashMap的实现，只不过这里取出来的数据不是链接，是Entry对象。 其他方法不再赘述，有兴趣的同学可以自行查看HashMap与ThreadLocalMap源码做比较。 没有看过HashMap源码的同学也可以看这篇HashMap源码解析 代码分析 通过上面的代码可以看到，每次set(）以及get()都会获取到当前线程再做后续的操作，保证所有的数据跟当前的线程相关联，不干扰其他线程。 在 set()和 get() 我们可以看到，保存数据的ThreadLocalMap对象，其实是保存在当前线程中，并不是保存在ThreadLocal中，也就解释了，为什么不同的线程可以取到自己线程中保存的值，ThreadLocal只是起到了key的左右。 数据真正保存在ThreadLocalMap中，再看一下getEntry()，通过threadLocal的threadLocalHashCode来确定返回值，这个就相当于threadLocal为key获取到之前保存的数据。同时每次new ThreadLocal对象时，threadLocalHashCode做了相对性的自增，这样可以保证多个threadLocal对象能被正确区分。 ThreadLocal保存的数据对象是T类型，意味着我们要存多个数据时可以保存Map或者List等类型，不用没保存一个数据就new一个对象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2FHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020180417%2F</url>
    <content type="text"><![CDATA[本文针对HashMap源码中的一些重要方法做讲解。Android中的HashMap与java中HashMap实现有差异，这里以Android的源码为例进行讲解。成员变量说明1234561. int DEFAULT_INITIAL_CAPACITY = 4；//默认初始化的容量2. int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //HashMap最大的容量3. float DEFAULT_LOAD_FACTOR = 0.75f; //判断是否扩容时用的计算因子4. int threshold ; //用于比较是否该扩容，其值为 capacity * load factor5. int size; //当前存储的数据容量6. HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE;//数据存储在这 成员变量tableHashMap内部实现的是Map.Entry 的，数据以数组形式保存的链表。 1transient HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE; 看一下HashMapEntry里面的代码，很简单： 123456789 /** @hide */ // Android added. static class HashMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; HashMapEntry&lt;K,V&gt; next; int hash; ...&#125; 保存了数据的key、value、hash以及以及下一个数据，就是典型的链表储存形式。至于put进来的数据，如何确定保存在table中的位置，请看下文。 构造函数构造函数主要对初始化容量以及加载因子做了参数校验，以符合后续的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); //初始化容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; initialCapacity = MAXIMUM_CAPACITY; &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123; initialCapacity = DEFAULT_INITIAL_CAPACITY; &#125; //校验加载因子的准确性 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Android-Note: We always use the default load factor of 0.75f. // This might appear wrong but it's just awkward design. We always call // inflateTable() when table == EMPTY_TABLE. That method will take "threshold" // to mean "capacity" and then replace it with the real threshold (i.e, multiplied with // the load factor). //默认扩容的阀值就是初始的容量 threshold = initialCapacity; init(); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#125; 数据put操作最基本的数据保存的方法，下面细分讲解: 12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 操作流程如下： 内部回判断当前table是否为空，为空则初始化table， table不为空，则查询当前的key是否在table中有保存，有则用新value替换旧value，并返回旧value 若当前key未保存数据，则创建新的entry进行保存（中间有一步扩容的操作） table初始化123456789101112131415161718192021 /** * Inflates the table. */ private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize //取最靠近（大于等于）toSize的2的整数倍值 int capacity = roundUpToPowerOf2(toSize); // Android-changed: Replace usage of Math.min() here because this method is // called from the &lt;clinit&gt; of runtime, at which point the native libraries // needed by Float.* might not be loaded. float thresholdFloat = capacity * loadFactor; if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123; thresholdFloat = MAXIMUM_CAPACITY + 1; &#125;//真正初始化临界值 threshold = (int) thresholdFloat; table = new HashMapEntry[capacity]; &#125; 看一下里面取2整数倍的方法 12345678910 private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : "number must be non-negative"; int rounded = number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (rounded = Integer.highestOneBit(number)) != 0//最高位为0，直接返回1 ? (Integer.bitCount(number) &gt; 1) ? rounded &lt;&lt; 1 : rounded//如果高位1的个数大于1，肯定不是2的整数倍，rounded扩大一倍，保证比number大 : 1; return rounded;&#125; 对于里面Integer.bitCount()不理解的同学可以参考这篇文章 Integer.bitCount实现过程 value存储对key进行判断，若key为null则存储到table的第一位，否则查找应该存储的位置 12int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);int i = indexFor(hash, table.length); 每次put以及get都会用到上面2个方法，hash值用于确定entry在table中的位置 看一下indexFor() 123456789101112131415161718192021222324 /** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; //上文可以知道table的length一定为2的倍数，这里length-1转换成二进制的时候可以肯定所有的位数都为1， //h &amp; (length-1)可以保证不同的hash值在table里分布 return h &amp; (length-1); &#125;``` 获取到index之后，去查找对应的链表，并循环遍历是否有保存的value，有则替换，否则插入新数据```java for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 来看一下插入数据的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; //这里用到了上面提到的threshold，到达临界值，同时当前插入的位置上有链表后，进行扩容，并将数据重新存入（length改变后，同一个hash值通过indexFor()计算得到的位置可能会变） if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125;``` ### 数据get操作相对put操作，get就比较简单了```java /** * Returns the entry associated with the specified key in the * HashMap. Returns null if the HashMap contains no mapping * for the key. */ final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; // 找到table中的链表位置后遍历循环比较取出数据即可 int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 遍历遍历的方法主要有3个 keySet(); values(); entrySet(); 这三个方法内部都是用的各自实现的HashIterator来进行遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; HashMapEntry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot HashMapEntry&lt;K,V&gt; current; // current entry HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry HashMapEntry[] t = table; //找到第一个不为null的HashMapEntry while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); HashMapEntry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; //如果当前链表遍历完了，则查找下一个不为null的链表的位置 HashMapEntry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125;&#125; 总结 HashMap插入数据不同步，所以是线程不安全的 内部使用链表 + 数组的形式保存所有的数据 每次扩容都是当前容量的2倍]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码分析]]></title>
    <url>%2FLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020180410%2F</url>
    <content type="text"><![CDATA[集合系列中的LinkedList的源码解析LinkedList内部实现LinkedList内部定义的Node静态类1234567891011private static class Node&lt;E&gt; &#123; E item;//数据 Node&lt;E&gt; next;//下一个Node节点，当前为链表尾时为null Node&lt;E&gt; prev;//上一个Node节点，当前为链表头时为null Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 通过Node的定义可以知道，内部其实是一个双向链表，分别保存了前后两个节点的指向。 内部定义了两个成员变量first以及last，用于快速的获取当前数据的第一个和最后一个数据。不管是实现list还是queue，直接操作first和last方法只有如下4个： 123456789101112131415/** * Links e as first element. * 将元素添加到首位 */ private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode;//链表如果为空，则第一个元素也是最后一个元素 else f.prev = newNode;//修改之前元素的指向 size++; modCount++; &#125; 123456789101112131415/** * Links e as last element. * 将元素添加到末尾 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//链表如果为空，则第一个元素也是最后一个元素 else l.next = newNode;//修改之前元素的指向 size++; modCount++; &#125; 1234567891011121314151617181920/** * Unlinks non-null first node f. * 将一个非空的节点从首位移除 */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; 12345678910111213141516171819/** * Unlinks non-null last node l. * 将一个非空的节点从末尾移除 */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; 从上面的方法可以看到，操作first和last顶多就是修改一下指针的指向，效率很高。 关于位置的查找，最终调用的如下2个方法：12345678910111213141516171819 public int indexOf(Object o) &#123; int index = 0; //元素分为null以及非null两种情况，提交一点比较时的效率 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 12345678910111213141516 Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index);//index在前一半则从前往后遍历，否则从后往前，减少几次遍历，提高一点效率 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; List以及Dequeue的实现list以及Deque的抽象实现，内部其实都是调用到linkFirst()、linkLast()、unLinkFirst()、unLinkLast()不再赘述。 LinkedList特性 内部使用链表结构实现，特点是增、删快，查询慢（需要从头遍历） 实现了Deque接口，也可以当作Queue来使用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码解析]]></title>
    <url>%2FArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9020180409%2F</url>
    <content type="text"><![CDATA[本文主要对ArrayList源码做一次解析，以及个人的理解做一次记录ArrayList的实现通过对源码的阅读可以发现，ArrayList内部的所有操作，都是对内部初始化的 Object [] 的操作。这意味着对内部数据的查询相对较快速，因为数组有角标可以快速访问，相对的对数据进行增、删效率就没那么高了（数组定长，对数据的修改都是一次copy）里面的代码也相对比较简单，挑如下几个方面说一下主要的实现ArrayList数据操作主要方法get(int index);//获取指定位置的数据set(int index, E element);//将数据设置到指定位置add(E e);//将数据添加到最后add(int index, E element);//将数据添加到指定位置remove(int index);//移除指定位置的数据remove(Object o);//移除指定的数据clear();//清除所有数据addAll(Collection&lt;? extends E&gt; c);//将整个集合添加进去addAll(int index, Collection&lt;? extends E&gt; c);//从指定位置开始添加整个集合removeRange(int fromIndex, int toIndex);//删除指定范围的数据retainAll(Collection&lt;?&gt; c);//保留两个list的交集ArrayList对内部数据的操作主要有如上10个方法。在操作几个添加数据相关方法时会对当前的数组进行容量判断，如果不够则进行扩容，默认是增加当前容量的一半。对数据的增删主要通过System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);实现。System.arraycopy这个方法表示将src这个数组的数据从srcPos开始一共length长度的数据，复制到dest这个数组的destPos位之后。ArrayList的扩容先看如下这几个方法，实现的ArrayList扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 每次增删数据前都会判断当前数组的容量，判断的方法主要是ensureCapacity()和ensureCapacityInternal()，一个公开一个内部调用，调用之后如果数据容量不够都会调用grow()做扩容处理。 来看一下grow()代码实现,添加了注释。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//如果容量不够先扩容一半 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity;//还不够直接使用指定的容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity);//扩容至最大容量 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//数据重新拷贝赋值&#125; 方法分析看一下如下几个主要的方法 12345678910public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index);//这里相当于将数据做了一次移动，将index之后的数据统一往后移动了1位 elementData[index] = element;//同时将index的数据进行了重新复制 size++;&#125; 123456789101112131415public E remove(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved);//同add方法，这里将index之后的数据统一往前移动了1位 elementData[--size] = null; //同时这里是通过复制实现的移动最后一位数据现在是多余的，清除 return oldValue;&#125; 12345678910111213141516171819public boolean remove(Object o) &#123;//这里对数据做了是否为null的区分，节省了equals的比较 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678910private void fastRemove(int index) &#123; modCount++; //这一步的操作是判断是否是最后一位，最后一位不需要数据拷贝移位 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //最后一位数据肯定多余&#125; 12345678910111213141516171819 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount//这里确定是否需要将原数组的数据往后移位 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved);//将新数据拷贝进对应的位置 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 12345678910111213141516171819202122protected void removeRange(int fromIndex, int toIndex) &#123; // Android-changed : Throw an IOOBE if toIndex &lt; fromIndex as documented. // All the other cases (negative indices, or indices greater than the size // will be thrown by System#arrayCopy. if (toIndex &lt; fromIndex) &#123; throw new IndexOutOfBoundsException("toIndex &lt; fromIndex"); &#125; modCount++; //确定需要移位的数据 int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125;public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) //这里通过一个boolean值来区分，保留下的数据到底是不是交集 if (c.contains(elementData[r]) == complement) //这里很巧妙了保存了需要的数据 elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. //这里的if判断是防止上面try里面报异常，将已经修改的数据继续做保存操作 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; //清除多余的数据 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 总结 初始容量为10，每次扩容为当前容量的一半 内部维护一个size字段用于表示当前数据大小 主要通过System.arrayCopy()对数据做复制、移位等处理 由于内部使用数组实现，查询时可以通过脚标查询效率高，跟新数据则效率低]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合类分析]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%E7%B1%BB%E5%88%86%E6%9E%9020180409%2F</url>
    <content type="text"><![CDATA[本文主要对java中集合相关的知识点做一个汇总，后续会分析相关的常用子类继承关系图java集合继承关系如下所示：123456789101112131415161718Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack│└Set ├HashSet ├TreeSet └LinkedHashSetMap├Hashtable├HashMap├TreeMap├LinkedHashMap└WeakHashMap Collection没有直接的实现类，让其被继承产生了两个接口，如上图所示，就是Set和List。 Set中不能包含重复的元素，同时数据的存储并不是有序的（存入和取出的顺序不一定相同）。 List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。 集合中的另一个接口就是Map。Map包含了key-value对，Map不能包含重复的key，但是可以包含相同的value。 集合中所有的类都实现了Iterator接口，用于遍历、操作集合中的数据，主要有如下几个方法： hasNext()；是否还有下一个元素。 next()；返回下一个元素。 remove()；删除当前元素。 集合子类之间的区别 List ：list数据有序，可重复。可以通过索引进行数据的增、删、改。 Arraylist使用数组实现，相对应的查询快，修改慢。适用于经常查询的场景 LinkedList使用双向链表实现，相对应的查询慢，修改快。适用于经常修改数据的场景 Set：Set数据存放无序，不可重复。 HashSet通过hashCode()和equals()来保证数据的唯一性； TreeSet通过对元素实现Comparable接口或者TreeSet指定排序规则，让元素可排序，并通过这个比较元素是否是唯一的 Map：Map已键值对的形式存放数据，键不能重复，值可以重复。 HashMap：根据key的hashCode值和equals方法来区分不同的key，同时因为这个遍历时取到的key是无序的。线程不同步，相对于HashTab效率高。能存放一个null值的key（hashcode），同时不限制null值的value数量 HashTable：相对于HashMap，线程安全，同时效率也对于HashMap低。存储时键值都不能为null。 TreeMap：遍历时默认按key的升序排列，这意味着key不能为null。线程不同步。 LinkedHashMap：遍历时按key插入的顺序取出，有序，相对于HashMap效率略低。线程不同步，可存放一个key为null值，value不做限制。 总结看到Array，就要想到角标，查询快。 看到Link，就要想到first，last，有序。 看到Hash，就要想到hashCode，equals，无序。 看到Tree，就要想到两个接口。Comparable，Comparator，可排序。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9520180404%2F</url>
    <content type="text"><![CDATA[目前先更新冒泡排序以及选择排序的java实现，后序更新冒泡排序通过每次比较相邻两个数据的大小，将大的数据替换到右边，逐渐将大的数据往后排。因为每次交换完成上一次最大的数据总比这次最大的数据大，所以可以忽略与上一次之前的数据比较，减少比较的次数。代码实现很简单，两个for循环，外层for循环控制循环次数，内层for循环控制比较的数据1234567891011121314private void bubbleSort(int[] array) &#123; int length = array.length; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; &#125; 选择排序从第一个数开始，跟后面的数据做比较，如果后面的数据比前面的大，则将相互调换位置，直到数据排序完成为止。 123456789101112131415161718192021private void selectSort(int[] array) &#123; int length = array.length; for (int i = 0; i &lt; length - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; length; j++) &#123; if(array[j] &lt; array[i])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125; &#125; 快速排序快速排序是对冒泡排序的一种改进，基本思想是选定一个锚点数据，循环遍历调换数据，遍历结束后，锚点位置改变，同时锚点左边的所有数据都小于等于锚点数据，锚点有点的数据都大于等于锚点数据。左右两边依次递归调用，直到遍历完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void quickSort(int[] array) &#123; if (array.length == 0) &#123; return; &#125; quickSort(array, 0, array.length - 1); &#125; /** * 快速排序算法 */ private void quickSort(int[] array, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low; int j = high; int anchor = array[low]; //循环遍历，所有比anchor小的数据都放在anchor左边，比anchor大的数据放在右边 while (i &lt; j) &#123; //这里开始从队尾寻找比anchor小的数据的位置 while (anchor &lt;= array[j] &amp;&amp; j &gt; i) &#123; j--; &#125; //这里开始从队首寻找比anchor大的数据的位置 while (anchor &gt;= array[i] &amp;&amp; i &lt; j) &#123; i++; &#125; //不符合要求的数据位置进行替换 if (i &lt; j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; //到这里可以确定，j之后所有的数据都比anchor大 array[low] = array[j]; array[j] = anchor; quickSort(array, low, j - 1); quickSort(array, j + 1, high); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树遍历]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%8620180403%2F</url>
    <content type="text"><![CDATA[主要介绍二叉树的先、中、后序遍历，使用递归和栈两种实现方式二叉树的3中遍历方式先序遍历：先跟节点遍历，再依次遍历左子树和右子树中序遍历：先遍历左子树，再遍历跟节点，最后遍历右子树后序遍历：先依次左子树和右子树，最后遍历跟节点假设有如下图所示的二叉树定义Node节点12345678910111213141516public class Node &#123; Node parent; Node left; Node right; int index; Node(int index) &#123; this.index = index; &#125; @Override public String toString() &#123; return String.valueOf(index) + " "; &#125;&#125; 先序遍历 递归实现先序遍历 打印结果为：0 1 3 7 8 4 2 5 9 10 11 12 6 1234567891011121314/** * 先序遍历--递归 * * @param root 根节点 */private void DLR(Node root) &#123; if (null == root) &#123; return; &#125; System.out.print(root.toString()); DLR(root.left); DLR(root.right);&#125; 栈实现先序遍历 打印结果为：0 1 3 7 8 4 2 5 9 10 11 12 6 1234567891011121314151617181920212223242526/** * 先序遍历--栈 * &lt;p&gt; * 维护一个栈，将根节点入栈，然后只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。 * * @param root */ private void DLRWithStack(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node temp = stack.pop(); System.out.print(temp.toString()); if (temp.right != null) &#123; stack.push(temp.right); &#125; if (temp.left != null) &#123; stack.push(temp.left); &#125; &#125; &#125; 1234567891011121314151617181920212223/** * 先序遍历--栈 * &lt;p&gt; * 利用栈模拟递归过程实现循环先序遍历二叉树 * 这种方式具备扩展性，它模拟递归的过程，将左子树点不断的压入栈，直到null，然后处理栈顶节点的右子树 * * @param root 树的根节点 */ private void DLRWithStack_2(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; System.out.print(root.toString());//先访问再入栈 stack.push(root); root = root.left;//如果是null，出栈并处理右子树 &#125; root = stack.pop(); root = root.right; &#125; &#125; 中序遍历 递归实现中序遍历 打印结果为：7 3 8 1 4 0 9 5 11 10 12 2 6 1234567891011121314/** * 中序遍历--递归 * * @param root 根节点 */private void LDR(Node root) &#123; if (null == root) &#123; return; &#125; LDR(root.left); System.out.print(root.toString()); LDR(root.right);&#125; 栈实现中序遍历 打印结果为：7 3 8 1 4 0 9 5 11 10 12 2 6 1234567891011121314151617181920212223/** * 中序遍历--栈 * &lt;p&gt; * 利用栈模拟递归过程实现循环中序遍历二叉树 * 访问的时间是在左子树都处理完直到null的时候出栈并访问。 * * @param root 树的根节点 */private void LDRWithStack(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left;//如果是null，出栈并处理右子树 &#125; root = stack.pop(); System.out.print(root.toString()); root = root.right; &#125;&#125; 后序遍历 递归实现后序遍历 打印结果为：7 8 3 4 1 9 11 12 10 5 6 2 0 123456789101112131415/** * 后序遍历 * * @param root 根节点 */private void LRD(Node root) &#123; if (null == root) &#123; return; &#125; LRD(root.left); LRD(root.right); System.out.print(root.toString());&#125; 栈实现后序遍历 打印结果为：7 8 3 4 1 9 11 12 10 5 6 2 0 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 后序遍历--栈 * &lt;p&gt; * 后序遍历时先将左子树全入栈做遍历，取出右子树做新的遍历操作 * 由于会取出多次，添加标记来区分，防止重复遍历，这里用list做标记 * * @param root 根节点 */private void LRDWithStack(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); //标记是否被遍历过 List&lt;Node&gt; list = new ArrayList&lt;&gt;(); while (!stack.empty()) &#123; Node temp = stack.peek(); //若左子树尚未被遍历 if (temp.left != null &amp;&amp; !list.contains(temp.left)) &#123; temp = temp.left; while (temp != null) &#123; stack.push(temp); temp = temp.left; &#125; continue; &#125; //若右子树尚未被遍历 if (temp.right != null &amp;&amp; !list.contains(temp.right)) &#123; stack.push(temp.right); continue; &#125; Node node = stack.pop(); list.add(node); System.out.print(node.toString()); &#125;&#125; 层遍历二叉树 打印结果为：0 1 2 3 4 5 6 7 8 9 10 11 12 1234567891011121314151617181920212223242526/** * 层遍历 * * @param root 根节点 */private void layer(Node root) &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; Node node = queue.poll(); System.out.print(node.toString()); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125;&#125; 参考文献JAVA下实现二叉树的先序、中序、后序、层序遍历（递归和循环）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类初始化]]></title>
    <url>%2Fjava%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%9620180402%2F</url>
    <content type="text"><![CDATA[本文主要记录本人对java类初始化了解的一些知识点，内容不一定正确，希望对读者有所帮助类初始化的的基本流程虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。上面所说时显示的对象创建，还有几种隐式创建对象的方式：给String类型变量赋值时，若String对象在常量池中不存在，则创建一个新的String对象对String对象进行拼接操作，同上自动装箱机制可能会引起一个原子类型的包装类对象被创建。使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类，也即main函数。类的实例对象初始化基本如下：Static Field Initial (静态变量)Static Patch Initial （静态初始化块）Field Initial （变量）Field Patch Initial （初始化块）Structure Initial （构造器）上面第一条和第二条依据代码定义的顺序不同，执行的顺序也不同（定义在静态代码块中的变量可以被静态代码块赋值，但是不能被访问）以下几种特殊情况需要说明一下：单例模式123456789101112131415161718192021222324252627282930313233public class Test &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println(Singleton.m); &#125; static class Singleton &#123; private static Singleton sSingleton = new Singleton(); private static String sString; static &#123; if (null == sString) &#123; sString = "静态代码看初始化"; &#125; &#125; private Singleton() &#123; init(); &#125; private static void init() &#123; if (null == sString) &#123; sString = "init() 初始化"; &#125; &#125; static Singleton getInstance() &#123; return sSingleton; &#125; &#125;&#125; 打印的结果为：init() 初始化 因为在初始化Singleton时，先行初始化singleton静态变量，此时调用了构造函数，并对sString进行了赋值操作。所以这里的初始化顺序对构造器中的代码执行顺序提前到了静态代码块之前。 子类引用父类的静态变量导致的初始化123456789101112131415161718192021222324252627282930313233343536373839public class Test &#123; public static void main(String[] args) &#123; System.out.println(Child.sCount); &#125; static class Parent &#123; static int sCount = 100; static &#123; System.out.println("Parent static Patch Initial"); &#125; &#123; System.out.println("Parent Field Patch Initial"); &#125; public Parent() &#123; System.out.println("Parent Constructor Initial"); &#125; &#125; static class Child extends Parent &#123; static final Integer sCount = 100; static final String sString = "hello"; static &#123; System.out.println("Child static Patch Initial"); &#125; &#123; System.out.println("Child Field Patch Initial"); &#125; public Child() &#123; System.out.println("Child Constructor Initial"); &#125; &#125;&#125; 运行结果为： Parent static Patch Initial 100 对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只触发了父类的初始化而不会触发子类的初始化。 对类中的常量引用的初始化1234public static void main(String[] args) &#123; System.out.println(Child.sString); System.out.println(Child.sCount + "");&#125; 打印的结果分别是： hello Parent static Patch Initial — 100 String和基本的数据类型，会在编译期被放进类的常量池中，所有在调用时并没有对类进行初始化。 但是Integer类型的sCount，在编译期并不会被放入常量池，通过 ‘javap -v’对编译后的字节码文件可以知道，main函数的第18行调用到了getstatic的指令，触发了类的初始化 123456789101112131415161718192021222324252627282930313233343536&#123; public Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 7: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: new #6 // class java/lang/StringBuilder 14: dup 15: invokespecial #7 // Method java/lang/StringBuilder."&lt;init&gt;":()V 18: getstatic #8 // Field Test$Child.sCount:Ljava/lang/Integer; 21: invokevirtual #9 // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder; 24: ldc #10 // String 26: invokevirtual #11 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: invokevirtual #12 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 32: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 35: return LineNumberTable: line 10: 0 line 11: 8 line 12: 35&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java解析与分派]]></title>
    <url>%2Fjava%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%86%E6%B4%BE-md20180323%2F</url>
    <content type="text"><![CDATA[本文的目的近期在看java虚拟机相关的知识点，写下此文记录近期所学知识点。什么是静态解析静态解析指的是方法在程序真正执行前就有一个可确定的版本，并且这个方法的调用版本在运行期是不可变的，也就是调用目标在编译器进行编译时就必须确定下来，也即要求一个方法“编译器可知，运行期不可变”。在java中符合静态解析要求的方法主要有两大类，分别是静态方法和私有方法。私有方法不能被继承，静态方法不能被重写，这两个限制可以确定这些方法都只有唯一的版本，不存在方法的重写，这使得他们能被静态解析。Java虚拟机里共提供了四条方法调用字节指令，分别是invokestatic：调用静态方法。invokespecial：调用实例构造器方法、私有方法和父类方法。invokevirtual：调用所有的虚方法。invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用方法，符合这一条件的有静态方法、私有方法、实例构造器方法以及父类方法。这些方法包括final方法在内统称为非虚方法，与之相反的其他方法称之为虚方法final方法，虽然是被invokevirtual调用，但是由于其无法被覆写，可以在编译时期被编译器完全确定，所以也被当作非虚方法，Java语言规范中也明确说明了final方法是一种非虚方法。什么是分派相对于非虚方法，虚方法由于存在重载和覆写，方法的引用可能无法在编译器直接确定。分派根据调用时期，可以分为静态分派和动态分派，同时根据宗量数（方法的调用者和方法的型参统称为方法的宗量数）区分又可以分为单分派和多分派，组合可以分为静态单分派、静态多分派、动态单分派、动态多分派四种情况。静态分派先说结论：对于重载的方法，javac是通过形参的静态类型（静态类型编译期可知）来区分使用哪个重载版本，这就是静态分派123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SampleCode &#123; public static void main(String[] args) &#123; SampleCode sampleCode = new SampleCode(); Human human = new Human(); Human man = new Man(); Human woman = new Woman(); sampleCode.someOneSayHi(human); sampleCode.someOneSayHi(man); sampleCode.someOneSayHi(woman); human.sayHi(); man.sayHi(); woman.sayHi(); &#125; public void someOneSayHi(Human human) &#123; System.out.println("human say hi"); &#125; public void someOneSayHi(Man man) &#123; System.out.println("man say hi"); &#125; public void someOneSayHi(Woman woman) &#123; System.out.println("woman say hi"); &#125; public static class Human &#123; public void sayHi() &#123; System.out.println("I'm a human"); &#125; &#125; public static class Man extends Human &#123; @Override public void sayHi() &#123; System.out.println("I'm a man"); &#125; &#125; public static class Woman extends Human &#123; @Override public void sayHi() &#123; System.out.println("I'm a woman"); &#125; &#125;&#125; 在调用someOneSayHi()时，代码执行结果如下： 123human say hihuman say hihuman say hi 看代码，编译器是如何区分该调用哪个重载方法的呢，看这句 1Human man = new Man(); 这里Human表示man这个变量的静态类型，Man表示变量的实际类型。这两个类型在代码运行过程中都可以发生变化，静态类型仅在使用时发生变化，但是变量的类型并不会变化，同时最终的静态类型在编译器可知，实际类型则不同，需要到运行期才能确定。 从上可知，代码中的human、man、woman三个变量的静态类型都是Human，同时编译期可知，调用者又同为sampleCode，根据宗量数区分，调用哪个重载方法完全根据方法的静态类型来区分，可以判定调用someOneSayHi(Human human)这个重载方法。 动态分派在运行时根据变量的实际类型来确定是否向上转型调用子类方法的分派过程称为动态分派 在调用sayHi()时，代码执行结果如下： 123I'm a humanI'm a manI'm a woman 在判断调用子类还是父类方法时，如果只根据方法的静态类型来区分，无论如何都只会调用到父类的方法中。实际是根据子类不同调用的是不同子类中的覆写方法。 单分派和多分派多分派是指根据方法的宗量（方法的调用者和方法的参数）来判定调用哪个方法，当一个方法的调用有多于一个宗量时的分派叫做多分派。 根据上面的分析可以知道 对于重载方法，其判定的宗量有调用者这个动态类型和方法的参数两个宗量，java的静态分派是多分派。 对于覆写方法，其判定的宗量只有调用者（是父类还是子类）这个动态类型宗量，java是动态分派是单分派。 参考文献【深入Java虚拟机】之五：多态性实现机制——静态分派与动态分派]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Lambda表达式入门]]></title>
    <url>%2FJava8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A820180308%2F</url>
    <content type="text"><![CDATA[本文的目的在于快速的了解java 8 中lambda新特性，同时会对jdk中一些常用的api做介绍]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 基本命令行]]></title>
    <url>%2Fgit-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C20171212%2F</url>
    <content type="text"><![CDATA[本文主要对一些常用的git命令行进行了分类汇总初始化仓库1git init 文件添加到暂存区1git add test.txt 文件提交1git commit -m "test file commint" 文件删除1git rm test.txt 与远程仓库关联1git remote add origin git@server-name:path/repo-name.git 仓库地址替换123git remote rm origin（删除本地仓库关联的远端仓库地址）git remote add origin newUrl（添加新的仓库地址） push内容到远程分支123git push -u origin master (首次提交，将本地git默认创建的master分支跟远程代码库关联，并push)git push origin master（后续提交，如若远端没有这个分支，则自动新建分支） 版本回滚git reset 共有3种模式，分别是 git reset –mixed 保留现有工作区，但是会用指定的commit覆盖暂存区。 git reset –soft 保留暂存区，但是会清空工作区。 git reset –hard 简单粗暴，直接使用指定的commit的内容覆盖stage区以及工作区。 12345git reset --hard HEAD^ 回滚到上一版本git reset --hard HEAD^^ 回滚前到两个版本 git reset --hard 123456578 回滚到指定哈希值的版本号 撤销修改 尚未add的文件撤销修改 1git checkout -- test.txt (撤销当前工作区的修改，返回最新暂存区的内容) 针对于已经add到暂存区的文件 123git reset HEAD test.txt (回滚) git checkout -- test.txt (并丢弃) 针对已经commit，但是尚未push到远端的文件 1git reset --hard HEAD^ 回滚到上一版本 分支 查看当前分支 1git branch 新建分支 12345git checkout -b dev (新建并切换)git branch dev （新建分支）git checkout -b branch-name origin/branch-name(新建与远端对应的分支) 删除分支 1234567git branch -d devgit branch -D dev (忽略警告，强制删除)git fetch -p (删除没有远程对应分支的本地分支)git push --delete origin dev (删除远程分支) 切换分支 1git checkout master 切换到指定tag 1git checkout tag_name 合并分支(merge以及rebase两种) 123git merge dev (假设当前在master分支，则表示将dev合并到master上)git rebase dev(同上) 本地分支和远程分支做关联 1git branch --set-upstream dev origin/dev 拉取远端最新代码 1git pull tag管理 新建tag 1git tag v1.0.0 指定commit上添加tag 123git tag v1.0.0 xxxxxxgit tag -a v1.0.0 -m "add version 1.0.0 tag" xxxxxx (带提交的信息) 查看所有tag 1git tag 查看tag信息 1git show v1.0.0 删除tag 123git tag -d v1.0.0 （删除本地）git push origin :refs/tags/v1.0.0 (再删除远端的tag) push tag至远端 123git push origin v1.0.0 (push 指定tag)git push origin --tags (push所有tag) 获取远端tag 12345git fetch origin tag v1.0.0 (更新tag)git pull --tags (获取远端所有的tag)git pull --all (用于解决远端tag无法再本地显示的问题) 参考文献廖雪峰的官网-Git教程]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio如何将一个project引用为module]]></title>
    <url>%2FAndroid-Studio%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AAproject%E5%BC%95%E7%94%A8%E4%B8%BAmodule20171130%2F</url>
    <content type="text"><![CDATA[Project和Module的区别在Android Studio（以下简称：AS）中project中相当于eclipse的workspace也就是一个工作空间。在AS中Module就相当于一个单独项目App Module、Library Module以及Java Module的区别首先这三种module本质上没什么区别，主要区别在于AS在编译时根据不同的类型会生成不同的结果App Module编译生成apk文件，也就是我们的应用程序包。Java Module编译生成jar文件。Library Module编译生成aar文件，相对于jar文件，aar中包含有资源文件。如何将App Module转换成Libray Module引用新建两个project，如下图所示：新建完的project如下图所有，两个项目的app下build.gradle中可以看到类型都是“com.android.application”我们将需要被引用的project中的类型修改为library，如下图所示：接下来Sync一下，然后会得到一个如下错误提示：我们只需要把项目中的application id删除即可之后在主工程中import module选择我们修改好的project下的app文件夹，就是选中这个module导入因为主项目名也是app，这里直接使用app会有冲突，修改为自己喜欢的名字即可最后在主项目中的build.gradle中compile即可其他的问题swtich引起的问题，如下伪代码：1234567891011switch(id)&#123; case R.id.xxx: break; case R.id.yyy: break; case R.id.zzz: break; &#125; 这里在引用的时候就会报一个错误，提示id没有找到，这是因为引用的lib中id都不是final类型的，不能用在case中，这个时候只需要修改成 if() else() 的形式即可。对于大型项目的引用，这里的修就会比较繁琐。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码分析]]></title>
    <url>%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171130%2F</url>
    <content type="text"><![CDATA[什么是Retrofitretrofit 是Square公司为了方便网络请求，对自己okhttp底层网络请求进行了再一次封装的框架，意在简化网络请求调用。当然retrofit设计也并不单纯只为了okhttp服务，只是默认实现使用了okhttp。Retrofit的实现先来看retrofit的几个重要类RetrofitRetrofit adapts a Java interface to HTTP calls by using annotations on thedeclared methods to define how requests are made. Create instances using{@linkplain Builderthe builder} and pass your interface to {@link #create} to generate animplementation.通过动态代理的方式，解析方法申明上的注解来生成http请求。Retrofit实例主要充当一个适配器的角色。CallAn invocation of a Retrofit method that sends a request to a webserver andreturns a response.Each call yields its own HTTP request and response pair. Use {@link #clone}to make multiplecalls with the same parameters to the same webserver; this may be used toimplement polling or to retry a failed call.Retrofit方法的一个实现，向服务器发送一个请求，并返回一个响应保存了一对http的请求以及响应ConverterConvert objects to and from their representation in HTTP. Instances arecreated by {@linkplainFactory a factory} which is {@linkplainRetrofit.Builder#addConverterFactory(Factory) installed}into the {@link Retrofit} instance.对http响应进行转换，转换成请求接口需要的返回类型CallAdapterAdapts a {@link Call} with response type {@code R} into the type of {@codeT}. Instances arecreated by {@linkplain Factory a factory} which is{@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} intothe {@link Retrofit}instance.对请求进行适配，以满足接口要求ServiceMethodAdapts an invocation of an interface method into an HTTP call.将定义的网络请求方法适配成一个http callParameterHandlerServiceMethod解析参数时具体值保存的位置RequestBuilder构建一个初始的RequestRetrofit发起请求的过程先看一下调用的代码。Retrofit创建时使用的动态代理方式，中间的Platform就是根据不同的平台做了兼容。这里可以很清晰看到，对service进行代理，通过其中的method构建一个serviceMethod，进而new出okHttpCall,并使用serviceMethod内部持有的callAdapter对okHttpCall进行网路请求以及适配成用户期望的返回类型，完成一次网络请求。1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; ServiceMethod的构建 ServiceMethodg构建过程主要是对Service中定义的网络请求进行注解的解析处理，将完成的参数保存在ParameterHandler中以便后续取用，至于注解参数的获取比较琐碎，这里不做赘述。 CallAdapter的获取 1234567891011121314151617private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( "Method return type must not include a type variable or wildcard: %s", returnType); &#125; if (returnType == void.class) &#123; throw methodError("Service methods cannot return void."); &#125; Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, "Unable to create call adapter for %s", returnType); &#125; &#125; 这里开始用到了工厂模式，使用CallAdapter.Factory的方式来获取CallAdapter。我们知道在构建Retrofit时是可以addCallAdapterFactory的，这就意味着我们可以自己实现CallAdapter，提供给Retrofit使用，提高代码的扩展性。 通过遍历Retrofit中保存的CallAdapter.Factory列表获取到符合条件的Factory用做请求的转换。 通过上面代码可以知道，实际上获取到的时候是retrofit中默认初始化的CallAdapter 默认CallAdapter 在Retrofit build过程中可以看到如下代码 123456789 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); 通过平台的适配我们获取到的platform其实是如下Android平台 123456789101112131415161718static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125; &#125; 通过安卓平台可以初始化一个默认的ExecutorCallAdapterFactory，用以获取默认的CallAdapter。 通过ExecutorCallAdapterFactory可以get到一个CallAdapter的实现，并将Call适配成一个ExecutorCallbackCall，内部处理了网络请求以及线程的切换。 请求的梳理 通过上面的分析知道，默认的请求过程如下： 对Service进行动态代理 构建出ServiceMethod 通过ServiceMethod构建出OkHttpCall 通过ServiceMethod中的CallAdapter实际也就是ExecutorCallAdapterFactory，对OkHttpCall进行适配获取到我们所需要的Call对象 得到用户需要的Call之后就可以进行execute或者enqueue操作。 到这里基本的网络请求算是完了。 ·～～～～～～～～～～～～～～～～～～· ·～～～～～～～～～～～～～～～～～～· ·～～～～～～我是分割线～～～～～～～· ·～～～～～～～～～～～～～～～～～～· ·～～～～～～～～～～～～～～～～～～· 等等！是不是感觉漏掉了什么东西，前面提到的Converter好像用到。 开头说过Converter是对响应做了转换，那肯定是在Call中用到，那我们回过头去看OkHttpCall的构建。 OkHttpCall 主要看一下response的解析 123456789101112131415161718192021222324252627282930313233343536Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125; 我们来看这一句 1T body = serviceMethod.toResponse(catchingBody); 往上追溯到头可以知道，实际代码如下 1234567891011121314public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; checkNotNull(type, "type == null"); checkNotNull(annotations, "annotations == null"); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; 也就是我们常设置的GsonConverterFactory会在这里被取用，并对真正的response做解析。 至此一个完整的网络请求以及参数的解析都完整结束了 总结 Retrofit本身就是个适配器，用以协调资源 动态代码模式，每个请求都是动态生成 静态代理模式，如返回给我们的ExecutorCallbackCall，实际是对内部Call一个代理对象 builder模式，简化对象的构建 使用了工厂模式，同时提高了代码的定制性 适配器模式，将原始的响应适配成实际需要的类型]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码分析]]></title>
    <url>%2FEventBus3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171123%2F</url>
    <content type="text"><![CDATA[什么是EventBus根据官方介绍，eventbus是一个通过分布/观察者模式实现的消息总线，支持不同线程的调用，能极大的降低代码的耦合度。EventBus的设计先上图，官方介绍流程图如下也很简单，就是通过Publisher post事件到eventbus，之后发送给subscriber进行处理。很明显事件的分发处理在eventbus中，那我们就先从eventbus开始看起。EventBus实现实例获取方式如下，典型的单例模式：1234567891011/** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; 再来看一下构造方法： 1234567891011121314151617181920212223242526/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */ public EventBus() &#123; this(DEFAULT_BUILDER); &#125; EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 初始化一些成员变量，同时获取builder中的默认参数进行初始化。 上图是eventbus的成员变量，通过变量名不难知道，主要是做了3部分的缓存： 当前发送的事件类型的class(eventTypes)，包含事件的父类以及实现的接口。这意味着你注册了一个事件的父类，发送这个事件时注册父类也会收到。 事件类型作为Key，Subscription(包含Subscriber和一个SubscriberMethod)的List集合作为Value的Map集合。 订阅者(Subscriber)作为Key，事件类型作为Value的Map集合。 Subscriber的注册流程1234567891011121314151617/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 通过subscriberMethodFinder.findSubscriberMethods()获取到subscriberMethods，并进行了subscribe操作。 订阅方法的查找以及缓存操作1234567891011121314151617181920212223List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //先取缓存中的数据 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //这是3.0新增的属性，是否强制使用反射的方式获取订阅方法 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //这边如果没有配置自定义的MyEventBusIndex还是使用反射的方式获取 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 说一下里面的主要方法findUsingReflection（），这里通过反射的方式获取到有的注册过的方法，并查找父类同样注册过的方法。查找的方式也是比较简单: 获取到所有的public修饰的， 不包含Modifier.ABSTRACT、Modifier.STATIC、BRIDGE、SYNTHETIC中的修饰 只有一个注解就是Subscribe的方法，最后缓存在METHOD_CACHE中。我们来看具体的代码实现 12345678910private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //这里就是初始化了一个FindState，通过while循环获取订阅类以及其父类的订阅方法，并做了缓存 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 主要的查找实现逻辑其实是在findUsingReflectionInSingleClass()中,也就是开始上面我们说的查找的规则，里面调用到的一个方法需要说一下，就是FindState.checkAddWithMethodSignature()这个方法 12345678910111213141516171819private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append('&gt;').append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); //这里判断了父类注册的方法是否被子类注册了 if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; 这个方法主要是判断了父类注册的方法是否被子类重写，如果被重写根据这个结果会抛出异常，限制了我们的子类去重写父类注册的方法。 注册事件监听以及注销上面说的方法的查询其实是注册的一部分，下面我们看方法查询完毕之后是怎么被注册上的。 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 很简单在subscribe()就是把查询出来的每个方法遍历操作，逐个生成Subscription，进行了缓存。 对重复注册的操作进行了抛出异常的处理，防止重复注册 在事件注册的同时还根据event注册时的优先级做了排序操作，之后缓存在内存中 对于sticky事件，这里在subscriber被注册时直接取出并交由subscriber进行了处理。 相对应的，在unregister()中，传入subscriber，将保存在subscriptionsByEventType已经typesBySubscriber中的缓存清除。 事件的发送123456789101112131415161718192021public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 从当前线程中获取PostingThreadState，并将需要发送的event插入队列中。PostingThreadState中保存了一个事件的队列、是否正在发送消息、是否在主线程、当前发送的事件、当前需要同时的订阅对象以及是否取消等的参数。 循环开启发送当个事件的操作，交由postSingleEvent()处理。 1234567891011121314151617181920212223private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; 这里eventInheritance的一个操作就是是否获取事件的父类并做处理，如果需要则获取所有的父类，并依次处理。 接下来就是事件的发送了 1234567891011121314151617181920212223242526private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 这里就是一个循环操作，将之前以eventType为key保存的所有Subscription获取出来，并处理event的过程。 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125; &#125; 上面就是最后的事件的分发处理的逻辑了，根据注册时指定的线程类型，发送到对应的线程中进行处理。 到此整个Eventbus事件注册，以及发送处理的逻辑都完毕了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsBride源码分析]]></title>
    <url>%2FJsBridge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171122%2F</url>
    <content type="text"><![CDATA[近期做项目，想要做一套native和js交互的规范，在网上搜索了一番之后发现，JsBride相对比较火。本文就JsBride的实现流程做一个分析。1. 几个基本类123456781、BridgeWebView：Android端的一些必要的初始化在这里，入口在此2、BridgeWebViewClient：js的一些初始化，以及事件的拦截在此3、BridgeUtil：初始化以及交互数据解析的工具类4、Message：交互的数据bean5、BridgeHandler：js数据返回后的回调处理6、WebViewJavascriptBridge：向js发送消息7、WebViewJavascriptBridge.js:这个文件在assets下，初始化了js中的消息队列等8、CallBackFunction：具体的回调 2. 主要流程图 先看android调用js方法的时序图（图片源自网络）： 再看js调用android方法的时序图（图片源自网络）： 3. 源码分析 先从入口BridgeWebView开始看起，BridgeWebView的主要方法以及成员变量入下图: 主要的成员变量 123456public static final String toLoadJs = "WebViewJavascriptBridge.js";//用于js的初始化，指定assets下的文件 Map&lt;String, CallBackFunction&gt; responseCallbacks = new HashMap&lt;String, CallBackFunction&gt;();//根据方法名或者callbackStr保存的js调用native后的回调列表 Map&lt;String, BridgeHandler&gt; messageHandlers = new HashMap&lt;String, BridgeHandler&gt;();//根据注册的方法名保存的js调用处理的handler BridgeHandler defaultHandler = new DefaultHandler();//默认的js调用处理 private List&lt;Message&gt; startupMessage = new ArrayList&lt;Message&gt;();//在js loadFinish前发送的消息 初始化，主要就是最后一句，初始化了一个WebViewClient()，这个就是最开头提到的BridgeWebViewClient，具体里面实现，后面再做分析。 123456789private void init() &#123; this.setVerticalScrollBarEnabled(false); this.setHorizontalScrollBarEnabled(false); this.getSettings().setJavaScriptEnabled(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; this.setWebViewClient(generateBridgeWebViewClient());&#125; 注册native方法，注册方法很简单： 12345public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; messageHandlers.put(handlerName, handler); &#125;&#125; 以方法名为key，回调处理为value本地维护一个map 调用js注册的方法： 123public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack); &#125; 最终内部实际调用是loadurl的形式 实际js调用native流程分析12345678910111213function testClick1() &#123; var str1 = document.getElementById("text1").value; var str2 = document.getElementById("text2").value; var data = "name=" + str1 + ",pass=" + str2; //call native method window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': data &#125; , function(responseData) &#123; document.getElementById("show").innerHTML = "send get responseData from java, data = " + responseData &#125; ); &#125; 上面一段代码很简单，就是定义了一个方法，通过js来调用Native的submitFromWeb(),并传递了data参数，以及回调方法。通过源码可以看到，实际调用为 1234567891011//sendMessage add message, 触发native处理 sendMessage function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE; &#125; 这里自定义了协议头，同时保存了callback 以及相对应的id。实际发送的链接形式为：“yy://QUEUE_MESSAGE/“开头的形式 我们接着来看native是如何处理调用的： 在BridgeWebViewClient中 123456789101112131415161718@Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; url = URLDecoder.decode(url, "UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据 webView.handlerReturnData(url); return true; &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; // webView.flushMessageQueue(); return true; &#125; else &#123; return super.shouldOverrideUrlLoading(view, url); &#125; &#125; 这里可以知道，js过来的url为“yy://QUEUE_MESSAGE/“ 走webView.flushMessageQueue()分支。 看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void flushMessageQueue() &#123; if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // deserializeMessage List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Message m = list.get(i); String responseId = m.getResponseId(); // 是否是response if (!TextUtils.isEmpty(responseId)) &#123; CallBackFunction function = responseCallbacks.get(responseId); String responseData = m.getResponseData(); function.onCallBack(responseData); responseCallbacks.remove(responseId); &#125; else &#123; CallBackFunction responseFunction = null; // if had callbackId final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125; &#125; 这里开始真正进入数据传递以及回调的流程了，有点绕。 先看loadurl()，这里BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA，可以看到是调用了 1234567// 提供给native调用,该函数作用:获取sendMessageQueue返回给native,由于android不能直接获取返回的内容,所以使用url shouldOverrideUrlLoading 的方式返回内容 function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //android can't read directly the return data, so we can reload iframe src to communicate with java messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125; 用来把真正要传递的给native的数据传递过来。我们来看调用了_fetchQueue()之后发生了什么。 js重新组装了一个url，链接形式为“yy://return/_fetchQueue + encodeURIComponent(messageQueueString)” 可以在BridgeWebViewClient中的shouldOverrideUrlLoading()中，走的是 webView.handlerReturnData(url)分支，看这里是如何处理代码的 12345678910void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125; &#125; 可以看到，这里把我们之前获取js传递给native数据时缓存的responseCallback取了出来。在responseCallback就是真正的数据处理了。里面的主要处理就是，根据js过来的message数据，判断js是否需要在处理完数据后回调给他（根据responseId来判断），若需要则在CallBackFunction中定义Message，并在回调时加入message队列中，再次通过loadurl的形式传递给js并处理，处理逻辑如下 12345678910111213141516171819202122232425262728293031323334353637383940//提供给native使用, function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; //java call finished, now need to call js callback function if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; //直接发送 if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; //查找指定handler try &#123; handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception); &#125; &#125; &#125; &#125;); &#125; native调用js native调用js流程和上面基本一致，只是native在shouldOverrideUrlLoading()根据responseId能查询到callback并处理数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webview</tag>
      </tags>
  </entry>
</search>

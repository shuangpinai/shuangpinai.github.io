<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git 基本命令行]]></title>
    <url>%2Fgit-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C20171212%2F</url>
    <content type="text"><![CDATA[本文主要对一些常用的git命令行进行了分类汇总初始化仓库1git init 文件添加到暂存区1git add test.txt 文件提交1git commit -m "test file commint" 文件删除1git rm test.txt 与远程仓库关联1git remote add origin git@server-name:path/repo-name.git push内容到远程分支123git push -u origin master (首次提交，将本地git默认创建的master分支跟远程代码库关联，并push)git push origin master（后续提交，如若远端没有这个分支，则自动新建分支） 版本回滚git reset 共有3种模式，分别是 git reset –mixed 保留现有工作区，但是会用指定的commit覆盖暂存区。 git reset –soft 保留暂存区，但是会清空工作区。 git reset –hard 简单粗暴，直接使用指定的commit的内容覆盖stage区以及工作区。 12345git reset --hard HEAD^ 回滚到上一版本git reset --hard HEAD^^ 回滚前到两个版本 git reset --hard 123456578 回滚到指定哈希值的版本号 撤销修改 尚未add的文件撤销修改 1git checkout -- test.txt (撤销当前工作区的修改，返回最新暂存区的内容) 针对于已经add到暂存区的文件 123git reset HEAD test.txt (回滚) git checkout -- test.txt (并丢弃) 针对已经commit，但是尚未push到远端的文件 1git reset --hard HEAD^ 回滚到上一版本 分支 查看当前分支 1git branch 新建分支 12345git checkout -b dev (新建并切换)git branch dev （新建分支）git checkout -b branch-name origin/branch-name(新建与远端对应的分支) 删除分支 12345678910111213 git branch -d dev git branch -D dev (忽略警告，强制删除) git fetch -p (删除没有远程对应分支的本地分支) git push --delete origin dev (删除远程分支) ``` - 切换分支 ```java git checkout master 合并分支(merge以及rebase两种) 123git merge dev (假设当前在master分支，则表示将dev合并到master上)git rebase dev(同上) 本地分支和远程分支做关联 1git branch --set-upstream dev origin/dev 拉取远端最新代码 123456789 git pull ``` ##### tag管理- 新建tag ```java git tag v1.0.0 指定commit上添加tag 123git tag v1.0.0 xxxxxxgit tag -a v1.0.0 -m "add version 1.0.0 tag" xxxxxx (带提交的信息) 查看所有tag 1git tag 查看tag信息 1git show v1.0.0 删除tag 123git tag -d v1.0.0 （删除本地）git push origin :refs/tags/v1.0.0 (再删除远端的tag) push tag至远端 123git push origin v1.0.0 (push 指定tag)git push origin --tags (push所有tag) 获取远端tag 12345git fetch origin tag v1.0.0 (更新tag)git pull --tags (获取远端所有的tag)git pull --all (用于解决远端tag无法再本地显示的问题) 参考文献廖雪峰的官网-Git教程]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio如何将一个project引用为module]]></title>
    <url>%2FAndroid-Studio%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AAproject%E5%BC%95%E7%94%A8%E4%B8%BAmodule20171130%2F</url>
    <content type="text"><![CDATA[Project和Module的区别在Android Studio（以下简称：AS）中project中相当于eclipse的workspace也就是一个工作空间。在AS中Module就相当于一个单独项目App Module、Library Module以及Java Module的区别首先这三种module本质上没什么区别，主要区别在于AS在编译时根据不同的类型会生成不同的结果App Module编译生成apk文件，也就是我们的应用程序包。Java Module编译生成jar文件。Library Module编译生成aar文件，相对于jar文件，aar中包含有资源文件。如何将App Module转换成Libray Module引用新建两个project，如下图所示：新建完的project如下图所有，两个项目的app下build.gradle中可以看到类型都是“com.android.application”我们将需要被引用的project中的类型修改为library，如下图所示：接下来Sync一下，然后会得到一个如下错误提示：我们只需要把项目中的application id删除即可之后在主工程中import module选择我们修改好的project下的app文件夹，就是选中这个module导入因为主项目名也是app，这里直接使用app会有冲突，修改为自己喜欢的名字即可最后在主项目中的build.gradle中compile即可其他的问题swtich引起的问题，如下伪代码：1234567891011switch(id)&#123; case R.id.xxx: break; case R.id.yyy: break; case R.id.zzz: break; &#125; 这里在引用的时候就会报一个错误，提示id没有找到，这是因为引用的lib中id都不是final类型的，不能用在case中，这个时候只需要修改成 if() else() 的形式即可。对于大型项目的引用，这里的修就会比较繁琐。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码分析]]></title>
    <url>%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171130%2F</url>
    <content type="text"><![CDATA[什么是Retrofitretrofit 是Square公司为了方便网络请求，对自己okhttp底层网络请求进行了再一次封装的框架，意在简化网络请求调用。当然retrofit设计也并不单纯只为了okhttp服务，只是默认实现使用了okhttp。Retrofit的实现先来看retrofit的几个重要类RetrofitRetrofit adapts a Java interface to HTTP calls by using annotations on thedeclared methods to define how requests are made. Create instances using{@linkplain Builderthe builder} and pass your interface to {@link #create} to generate animplementation.通过动态代理的方式，解析方法申明上的注解来生成http请求。Retrofit实例主要充当一个适配器的角色。CallAn invocation of a Retrofit method that sends a request to a webserver andreturns a response.Each call yields its own HTTP request and response pair. Use {@link #clone}to make multiplecalls with the same parameters to the same webserver; this may be used toimplement polling or to retry a failed call.Retrofit方法的一个实现，向服务器发送一个请求，并返回一个响应保存了一对http的请求以及响应ConverterConvert objects to and from their representation in HTTP. Instances arecreated by {@linkplainFactory a factory} which is {@linkplainRetrofit.Builder#addConverterFactory(Factory) installed}into the {@link Retrofit} instance.对http响应进行转换，转换成请求接口需要的返回类型CallAdapterAdapts a {@link Call} with response type {@code R} into the type of {@codeT}. Instances arecreated by {@linkplain Factory a factory} which is{@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} intothe {@link Retrofit}instance.对请求进行适配，以满足接口要求ServiceMethodAdapts an invocation of an interface method into an HTTP call.将定义的网络请求方法适配成一个http callParameterHandlerServiceMethod解析参数时具体值保存的位置RequestBuilder构建一个初始的RequestRetrofit发起请求的过程先看一下调用的代码。Retrofit创建时使用的动态代理方式，中间的Platform就是根据不同的平台做了兼容。这里可以很清晰看到，对service进行代理，通过其中的method构建一个serviceMethod，进而new出okHttpCall,并使用serviceMethod内部持有的callAdapter对okHttpCall进行网路请求以及适配成用户期望的返回类型，完成一次网络请求。1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; ServiceMethod的构建 ServiceMethodg构建过程主要是对Service中定义的网络请求进行注解的解析处理，将完成的参数保存在ParameterHandler中以便后续取用，至于注解参数的获取比较琐碎，这里不做赘述。 CallAdapter的获取 1234567891011121314151617private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( "Method return type must not include a type variable or wildcard: %s", returnType); &#125; if (returnType == void.class) &#123; throw methodError("Service methods cannot return void."); &#125; Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, "Unable to create call adapter for %s", returnType); &#125; &#125; 这里开始用到了工厂模式，使用CallAdapter.Factory的方式来获取CallAdapter。我们知道在构建Retrofit时是可以addCallAdapterFactory的，这就意味着我们可以自己实现CallAdapter，提供给Retrofit使用，提高代码的扩展性。 通过遍历Retrofit中保存的CallAdapter.Factory列表获取到符合条件的Factory用做请求的转换。 通过上面代码可以知道，实际上获取到的时候是retrofit中默认初始化的CallAdapter 默认CallAdapter 在Retrofit build过程中可以看到如下代码 123456789 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); 通过平台的适配我们获取到的platform其实是如下Android平台 123456789101112131415161718static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125; &#125; 通过安卓平台可以初始化一个默认的ExecutorCallAdapterFactory，用以获取默认的CallAdapter。 通过ExecutorCallAdapterFactory可以get到一个CallAdapter的实现，并将Call适配成一个ExecutorCallbackCall，内部处理了网络请求以及线程的切换。 请求的梳理 通过上面的分析知道，默认的请求过程如下： 对Service进行动态代理 构建出ServiceMethod 通过ServiceMethod构建出OkHttpCall 通过ServiceMethod中的CallAdapter实际也就是ExecutorCallAdapterFactory，对OkHttpCall进行适配获取到我们所需要的Call对象 得到用户需要的Call之后就可以进行execute或者enqueue操作。 到这里基本的网络请求算是完了。 ·～～～～～～～～～～～～～～～～～～· ·～～～～～～～～～～～～～～～～～～· ·～～～～～～我是分割线～～～～～～～· ·～～～～～～～～～～～～～～～～～～· ·～～～～～～～～～～～～～～～～～～· 等等！是不是感觉漏掉了什么东西，前面提到的Converter好像用到。 开头说过Converter是对响应做了转换，那肯定是在Call中用到，那我们回过头去看OkHttpCall的构建。 OkHttpCall 主要看一下response的解析 123456789101112131415161718192021222324252627282930313233343536Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125; 我们来看这一句 1T body = serviceMethod.toResponse(catchingBody); 往上追溯到头可以知道，实际代码如下 1234567891011121314public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; checkNotNull(type, "type == null"); checkNotNull(annotations, "annotations == null"); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; 也就是我们常设置的GsonConverterFactory会在这里被取用，并对真正的response做解析。 至此一个完整的网络请求以及参数的解析都完整结束了 总结 Retrofit本身就是个适配器，用以协调资源 动态代码模式，每个请求都是动态生成 静态代理模式，如返回给我们的ExecutorCallbackCall，实际是对内部Call一个代理对象 builder模式，简化对象的构建 使用了工厂模式，同时提高了代码的定制性 适配器模式，将原始的响应适配成实际需要的类型]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码分析]]></title>
    <url>%2FEventBus3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171123%2F</url>
    <content type="text"><![CDATA[什么是EventBus根据官方介绍，eventbus是一个通过分布/观察者模式实现的消息总线，支持不同线程的调用，能极大的降低代码的耦合度。EventBus的设计先上图，官方介绍流程图如下也很简单，就是通过Publisher post事件到eventbus，之后发送给subscriber进行处理。很明显事件的分发处理在eventbus中，那我们就先从eventbus开始看起。EventBus实现实例获取方式如下，典型的单例模式：1234567891011/** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; 再来看一下构造方法： 1234567891011121314151617181920212223242526/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */ public EventBus() &#123; this(DEFAULT_BUILDER); &#125; EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 初始化一些成员变量，同时获取builder中的默认参数进行初始化。 上图是eventbus的成员变量，通过变量名不难知道，主要是做了3部分的缓存： 当前发送的eventTypes 事件类型作为Key，Subscription的List集合作为Value的Map集合 订阅者作为Key,订阅事件作为Value的Map集合 Subscriber的注册流程1234567891011121314151617/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 通过subscriberMethodFinder.findSubscriberMethods()获取到subscriberMethods，并进行了subscribe操作。 订阅方法的查找以及缓存操作1234567891011121314151617181920212223List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //先取缓存中的数据 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //这是3.0新增的属性，是否强制使用反射的方式获取订阅方法 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //这边如果没有配置自定义的MyEventBusIndex还是使用放射的方式获取 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 说一下里面的主要方法findUsingReflection（），这里通过反射的方式获取到有的注册过的方法，并查找父类同样注册过的方法。查找的方式也是比较简单: 获取到所有的public修饰的， 不包含Modifier.ABSTRACT、Modifier.STATIC、BRIDGE、SYNTHETIC中的修饰 只有一个注解就是Subscribe的方法，最后缓存在METHOD_CACHE中。我们来看具体的代码实现 12345678910private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //这里就是初始化了一个FindState，并通过while循环获取订阅类以及其父类的订阅方法，并做了缓存 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 主要的查找实现逻辑其实是在findUsingReflectionInSingleClass()中,也就是开始上面我们说的查找的规则，里面调用到的一个方法需要说一下，就是FindState.checkAddWithMethodSignature()这个方法 12345678910111213141516171819private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append('&gt;').append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); //这里判断了父类注册的方法是否被子类注册了 if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; 这个方法主要是判断了父类注册的方法是否被子类重写，如果被重写根据这个结果会抛出异常，限制了我们的子类去重写父类注册的方法。 注册事件监听以及注销上面说的方法的查询其实是注册的一部分，下面我们看方法查询完毕之后是怎么被注册上的。 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 很简单在subscribe()就是把查询出来的每个方法遍历操作，逐个生成Subscription，进行了缓存。 对重复注册的操作进行了抛出异常的处理，防止重复注册 在事件注册的同时还根据event注册时的优先级做了排序操作，之后缓存在内存中 对于sticky事件，这里在subscriber被注册时直接取出并交由subscriber进行了处理。 相对应的，在unregister()中，传入subscriber，将保存在subscriptionsByEventType已经typesBySubscriber中的缓存清除。 事件的发送1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125;``` 从当前线程中获取PostingThreadState，并将需要发送的event插入队列中。PostingThreadState中保存了一个事件的队列、是否正在发送消息、是否在主线程、当前发送的事件、当前需要同时的订阅对象以及是否取消等的参数。循环开启发送当个事件的操作，交由postSingleEvent()处理。```javaprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; 这里eventInheritance的一个操作就是是否获取事件的父类并做处理，如果需要则获取所有的父类，并依次处理。 接下来就是事件的发送了 1234567891011121314151617181920212223242526private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 这里就是一个循环操作，将之前以eventType为key保存的所有Subscription获取出来，并处理event的过程。 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125; &#125; 上面就是最后的事件的分发处理的逻辑了，根据注册时指定的线程类型，发送到对应的线程中进行处理。 到此整个Eventbus事件注册，以及发送处理的逻辑都完毕了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsBride源码分析]]></title>
    <url>%2FJsBridge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171122%2F</url>
    <content type="text"><![CDATA[近期做项目，想要做一套native和js交互的规范，在网上搜索了一番之后发现，JsBride相对比较火。本文就JsBride的实现流程做一个分析。1. 几个基本类123456781、BridgeWebView：Android端的一些必要的初始化在这里，入口在此2、BridgeWebViewClient：js的一些初始化，以及事件的拦截在此3、BridgeUtil：初始化以及交互数据解析的工具类4、Message：交互的数据bean5、BridgeHandler：js数据返回后的回调处理6、WebViewJavascriptBridge：向js发送消息7、WebViewJavascriptBridge.js:这个文件在assets下，初始化了js中的消息队列等8、CallBackFunction：具体的回调 2. 主要流程图 先看android调用js方法的时序图（图片源自网络）： 再看js调用android方法的时序图（图片源自网络）： 3. 源码分析 先从入口BridgeWebView开始看起，BridgeWebView的主要方法以及成员变量入下图: 主要的成员变量 123456public static final String toLoadJs = "WebViewJavascriptBridge.js";//用于js的初始化，指定assets下的文件 Map&lt;String, CallBackFunction&gt; responseCallbacks = new HashMap&lt;String, CallBackFunction&gt;();//根据方法名或者callbackStr保存的js调用native后的回调列表 Map&lt;String, BridgeHandler&gt; messageHandlers = new HashMap&lt;String, BridgeHandler&gt;();//根据注册的方法名保存的js调用处理的handler BridgeHandler defaultHandler = new DefaultHandler();//默认的js调用处理 private List&lt;Message&gt; startupMessage = new ArrayList&lt;Message&gt;();//在js loadFinish前发送的消息 初始化，主要就是最后一句，初始化了一个WebViewClient()，这个就是最开头提到的BridgeWebViewClient，具体里面实现，后面再做分析。 123456789private void init() &#123; this.setVerticalScrollBarEnabled(false); this.setHorizontalScrollBarEnabled(false); this.getSettings().setJavaScriptEnabled(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; this.setWebViewClient(generateBridgeWebViewClient());&#125; 注册native方法，注册方法很简单： 12345public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; messageHandlers.put(handlerName, handler); &#125;&#125; 以方法名为key，回调处理为value本地维护一个map 调用js注册的方法： 123public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack); &#125; 最终内部实际调用是loadurl的形式 实际js调用native流程分析12345678910111213function testClick1() &#123; var str1 = document.getElementById("text1").value; var str2 = document.getElementById("text2").value; var data = "name=" + str1 + ",pass=" + str2; //call native method window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': data &#125; , function(responseData) &#123; document.getElementById("show").innerHTML = "send get responseData from java, data = " + responseData &#125; ); &#125; 上面一段代码很简单，就是定义了一个方法，通过js来调用Native的submitFromWeb(),并传递了data参数，以及回调方法。通过源码可以看到，实际调用为 1234567891011//sendMessage add message, 触发native处理 sendMessage function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE; &#125; 这里自定义了协议头，同时保存了callback 以及相对应的id。实际发送的链接形式为：“yy://QUEUE_MESSAGE/“开头的形式 我们接着来看native是如何处理调用的： 在BridgeWebViewClient中 123456789101112131415161718@Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; url = URLDecoder.decode(url, "UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据 webView.handlerReturnData(url); return true; &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; // webView.flushMessageQueue(); return true; &#125; else &#123; return super.shouldOverrideUrlLoading(view, url); &#125; &#125; 这里可以知道，js过来的url为“yy://QUEUE_MESSAGE/“ 走webView.flushMessageQueue()分支。 看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void flushMessageQueue() &#123; if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // deserializeMessage List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Message m = list.get(i); String responseId = m.getResponseId(); // 是否是response if (!TextUtils.isEmpty(responseId)) &#123; CallBackFunction function = responseCallbacks.get(responseId); String responseData = m.getResponseData(); function.onCallBack(responseData); responseCallbacks.remove(responseId); &#125; else &#123; CallBackFunction responseFunction = null; // if had callbackId final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125; &#125; 这里开始真正进入数据传递以及回调的流程了，有点绕。 先看loadurl()，这里BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA，可以看到是调用了 1234567// 提供给native调用,该函数作用:获取sendMessageQueue返回给native,由于android不能直接获取返回的内容,所以使用url shouldOverrideUrlLoading 的方式返回内容 function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //android can't read directly the return data, so we can reload iframe src to communicate with java messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125; 用来把真正要传递的给native的数据传递过来。我们来看调用了_fetchQueue()之后发生了什么。 js重新组装了一个url，链接形式为“yy://return/_fetchQueue + encodeURIComponent(messageQueueString)” 可以在BridgeWebViewClient中的shouldOverrideUrlLoading()中，走的是 webView.handlerReturnData(url)分支，看这里是如何处理代码的 12345678910void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125; &#125; 可以看到，这里把我们之前获取js传递给native数据时缓存的responseCallback取了出来。在responseCallback就是真正的数据处理了。里面的主要处理就是，根据js过来的message数据，判断js是否需要在处理完数据后回调给他（根据responseId来判断），若需要则在CallBackFunction中定义Message，并在回调时加入message队列中，再次通过loadurl的形式传递给js并处理，处理逻辑如下 12345678910111213141516171819202122232425262728293031323334353637383940//提供给native使用, function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; //java call finished, now need to call js callback function if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; //直接发送 if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; //查找指定handler try &#123; handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception); &#125; &#125; &#125; &#125;); &#125; native调用js native调用js流程和上面基本一致，只是native在shouldOverrideUrlLoading()根据responseId能查询到callback并处理数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webview</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Studio如何将一个project引用为module]]></title>
    <url>%2FAndroid-Studio%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AAproject%E5%BC%95%E7%94%A8%E4%B8%BAmodule20171130%2F</url>
    <content type="text"><![CDATA[Project和Module的区别在Android Studio（以下简称：AS）中project中相当于eclipse的workspace也就是一个工作空间。在AS中Module就相当于一个单独项目App Module、Library Module以及Java Module的区别首先这三种module本质上没什么区别，主要区别在于AS在编译时根据不同的类型会生成不同的结果App Module编译生成apk文件，也就是我们的应用程序包。Java Module编译生成jar文件。Library Module编译生成aar文件，相对于jar文件，aar中包含有资源文件。如何将App Module转换成Libray Module引用新建两个project，如下图所示：新建完的project如下图所有，两个项目的app下build.gradle中可以看到类型都是“com.android.application”我们将需要被引用的project中的类型修改为library，如下图所示：接下来Sync一下，然后会得到一个如下错误提示：我们只需要把项目中的application id删除即可之后在主工程中import module选择我们修改好的project下的app文件夹，就是选中这个module导入因为主项目名也是app，这里直接使用app会有冲突，修改为自己喜欢的名字即可最后在主项目中的build.gradle中compile即可其他的问题swtich引起的问题，如下伪代码：1234567891011switch(id)&#123; case R.id.xxx: break; case R.id.yyy: break; case R.id.zzz: break; &#125; 这里在引用的时候就会报一个错误，提示id没有找到，这是因为引用的lib中id都不是final类型的，不能用在case中，这个时候只需要修改成 if() else() 的形式即可。对于大型项目的引用，这里的修就会比较繁琐。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码分析]]></title>
    <url>%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171130%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码分析]]></title>
    <url>%2FEventBus3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171123%2F</url>
    <content type="text"><![CDATA[什么是EventBus根据官方介绍，eventbus是一个通过分布/观察者模式实现的消息总线，支持不同线程的调用，能极大的降低代码的耦合度。EventBus的设计先上图，官方介绍流程图如下也很简单，就是通过Publisher post事件到eventbus，之后发送给subscriber进行处理。很明显事件的分发处理在eventbus中，那我们就先从eventbus开始看起。EventBus实现实例获取方式如下，典型的单例模式：1234567891011/** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; 再来看一下构造方法： 1234567891011121314151617181920212223242526/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */ public EventBus() &#123; this(DEFAULT_BUILDER); &#125; EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 初始化一些成员变量，同时获取builder中的默认参数进行初始化。 上图是eventbus的成员变量，通过变量名不难知道，主要是做了3部分的缓存： 当前发送的eventTypes 事件类型作为Key，Subscription的List集合作为Value的Map集合 订阅者作为Key,订阅事件作为Value的Map集合 Subscriber的注册流程1234567891011121314151617/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 通过subscriberMethodFinder.findSubscriberMethods()获取到subscriberMethods，并进行了subscribe操作。 订阅方法的查找以及缓存操作1234567891011121314151617181920212223List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //先取缓存中的数据 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //这是3.0新增的属性，是否强制使用反射的方式获取订阅方法 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //这边如果没有配置自定义的MyEventBusIndex还是使用放射的方式获取 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 说一下里面的主要方法findUsingReflection（），这里通过反射的方式获取到有的注册过的方法，并查找父类同样注册过的方法。查找的方式也是比较简单: 获取到所有的public修饰的， 不包含Modifier.ABSTRACT、Modifier.STATIC、BRIDGE、SYNTHETIC中的修饰 只有一个注解就是Subscribe的方法，最后缓存在METHOD_CACHE中。我们来看具体的代码实现 12345678910private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //这里就是初始化了一个FindState，并通过while循环获取订阅类以及其父类的订阅方法，并做了缓存 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 主要的查找实现逻辑其实是在findUsingReflectionInSingleClass()中,也就是开始上面我们说的查找的规则，里面调用到的一个方法需要说一下，就是FindState.checkAddWithMethodSignature()这个方法 12345678910111213141516171819private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append('&gt;').append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); //这里判断了父类注册的方法是否被子类注册了 if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; 这个方法主要是判断了父类注册的方法是否被子类重写，如果被重写根据这个结果会抛出异常，限制了我们的子类去重写父类注册的方法。 注册事件监听以及注销上面说的方法的查询其实是注册的一部分，下面我们看方法查询完毕之后是怎么被注册上的。 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 很简单在subscribe()就是把查询出来的每个方法遍历操作，逐个生成Subscription，进行了缓存。 对重复注册的操作进行了抛出异常的处理，防止重复注册 在事件注册的同时还根据event注册时的优先级做了排序操作，之后缓存在内存中 对于sticky事件，这里在subscriber被注册时直接取出并交由subscriber进行了处理。 相对应的，在unregister()中，传入subscriber，将保存在subscriptionsByEventType已经typesBySubscriber中的缓存清除。 事件的发送1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125;``` 从当前线程中获取PostingThreadState，并将需要发送的event插入队列中。PostingThreadState中保存了一个事件的队列、是否正在发送消息、是否在主线程、当前发送的事件、当前需要同时的订阅对象以及是否取消等的参数。循环开启发送当个事件的操作，交由postSingleEvent()处理。```javaprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; 这里eventInheritance的一个操作就是是否获取事件的父类并做处理，如果需要则获取所有的父类，并依次处理。 接下来就是事件的发送了 1234567891011121314151617181920212223242526private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 这里就是一个循环操作，将之前以eventType为key保存的所有Subscription获取出来，并处理event的过程。 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125; &#125; 上面就是最后的事件的分发处理的逻辑了，根据注册时指定的线程类型，发送到对应的线程中进行处理。 到此整个Eventbus事件注册，以及发送处理的逻辑都完毕了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsBride源码分析]]></title>
    <url>%2FJsBridge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9020171122%2F</url>
    <content type="text"><![CDATA[近期做项目，想要做一套native和js交互的规范，在网上搜索了一番之后发现，JsBride相对比较火。本文就JsBride的实现流程做一个分析。1. 几个基本类123456781、BridgeWebView：Android端的一些必要的初始化在这里，入口在此2、BridgeWebViewClient：js的一些初始化，以及事件的拦截在此3、BridgeUtil：初始化以及交互数据解析的工具类4、Message：交互的数据bean5、BridgeHandler：js数据返回后的回调处理6、WebViewJavascriptBridge：向js发送消息7、WebViewJavascriptBridge.js:这个文件在assets下，初始化了js中的消息队列等8、CallBackFunction：具体的回调 2. 主要流程图 先看android调用js方法的时序图（图片源自网络）： 再看js调用android方法的时序图（图片源自网络）： 3. 源码分析 先从入口BridgeWebView开始看起，BridgeWebView的主要方法以及成员变量入下图: 主要的成员变量 123456public static final String toLoadJs = "WebViewJavascriptBridge.js";//用于js的初始化，指定assets下的文件 Map&lt;String, CallBackFunction&gt; responseCallbacks = new HashMap&lt;String, CallBackFunction&gt;();//根据方法名或者callbackStr保存的js调用native后的回调列表 Map&lt;String, BridgeHandler&gt; messageHandlers = new HashMap&lt;String, BridgeHandler&gt;();//根据注册的方法名保存的js调用处理的handler BridgeHandler defaultHandler = new DefaultHandler();//默认的js调用处理 private List&lt;Message&gt; startupMessage = new ArrayList&lt;Message&gt;();//在js loadFinish前发送的消息 初始化，主要就是最后一句，初始化了一个WebViewClient()，这个就是最开头提到的BridgeWebViewClient，具体里面实现，后面再做分析。 123456789private void init() &#123; this.setVerticalScrollBarEnabled(false); this.setHorizontalScrollBarEnabled(false); this.getSettings().setJavaScriptEnabled(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; this.setWebViewClient(generateBridgeWebViewClient());&#125; 注册native方法，注册方法很简单： 12345public void registerHandler(String handlerName, BridgeHandler handler) &#123; if (handler != null) &#123; messageHandlers.put(handlerName, handler); &#125;&#125; 以方法名为key，回调处理为value本地维护一个map 调用js注册的方法： 123public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; doSend(handlerName, data, callBack); &#125; 最终内部实际调用是loadurl的形式 实际js调用native流程分析12345678910111213function testClick1() &#123; var str1 = document.getElementById("text1").value; var str2 = document.getElementById("text2").value; var data = "name=" + str1 + ",pass=" + str2; //call native method window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': data &#125; , function(responseData) &#123; document.getElementById("show").innerHTML = "send get responseData from java, data = " + responseData &#125; ); &#125; 上面一段代码很简单，就是定义了一个方法，通过js来调用Native的submitFromWeb(),并传递了data参数，以及回调方法。通过源码可以看到，实际调用为 1234567891011//sendMessage add message, 触发native处理 sendMessage function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE; &#125; 这里自定义了协议头，同时保存了callback 以及相对应的id。实际发送的链接形式为：“yy://QUEUE_MESSAGE/“开头的形式 我们接着来看native是如何处理调用的： 在BridgeWebViewClient中 123456789101112131415161718@Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; url = URLDecoder.decode(url, "UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; // 如果是返回数据 webView.handlerReturnData(url); return true; &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; // webView.flushMessageQueue(); return true; &#125; else &#123; return super.shouldOverrideUrlLoading(view, url); &#125; &#125; 这里可以知道，js过来的url为“yy://QUEUE_MESSAGE/“ 走webView.flushMessageQueue()分支。 看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void flushMessageQueue() &#123; if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // deserializeMessage List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Message m = list.get(i); String responseId = m.getResponseId(); // 是否是response if (!TextUtils.isEmpty(responseId)) &#123; CallBackFunction function = responseCallbacks.get(responseId); String responseData = m.getResponseData(); function.onCallBack(responseData); responseCallbacks.remove(responseId); &#125; else &#123; CallBackFunction responseFunction = null; // if had callbackId final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125; &#125; 这里开始真正进入数据传递以及回调的流程了，有点绕。 先看loadurl()，这里BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA，可以看到是调用了 1234567// 提供给native调用,该函数作用:获取sendMessageQueue返回给native,由于android不能直接获取返回的内容,所以使用url shouldOverrideUrlLoading 的方式返回内容 function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //android can't read directly the return data, so we can reload iframe src to communicate with java messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125; 用来把真正要传递的给native的数据传递过来。我们来看调用了_fetchQueue()之后发生了什么。 js重新组装了一个url，链接形式为“yy://return/_fetchQueue + encodeURIComponent(messageQueueString)” 可以在BridgeWebViewClient中的shouldOverrideUrlLoading()中，走的是 webView.handlerReturnData(url)分支，看这里是如何处理代码的 12345678910void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125; &#125; 可以看到，这里把我们之前获取js传递给native数据时缓存的responseCallback取了出来。在responseCallback就是真正的数据处理了。里面的主要处理就是，根据js过来的message数据，判断js是否需要在处理完数据后回调给他（根据responseId来判断），若需要则在CallBackFunction中定义Message，并在回调时加入message队列中，再次通过loadurl的形式传递给js并处理，处理逻辑如下 12345678910111213141516171819202122232425262728293031323334353637383940//提供给native使用, function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; //java call finished, now need to call js callback function if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; //直接发送 if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; //查找指定handler try &#123; handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception); &#125; &#125; &#125; &#125;); &#125; native调用js native调用js流程和上面基本一致，只是native在shouldOverrideUrlLoading()根据responseId能查询到callback并处理数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webview</tag>
      </tags>
  </entry>
</search>
